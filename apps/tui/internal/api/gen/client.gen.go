// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for ReaderAnnotationsGetManyParamsOrderDirection.
const (
	ReaderAnnotationsGetManyParamsOrderDirectionAsc  ReaderAnnotationsGetManyParamsOrderDirection = "asc"
	ReaderAnnotationsGetManyParamsOrderDirectionDesc ReaderAnnotationsGetManyParamsOrderDirection = "desc"
)

// Defines values for ReaderBookmarksGetManyParamsOrderDirection.
const (
	ReaderBookmarksGetManyParamsOrderDirectionAsc  ReaderBookmarksGetManyParamsOrderDirection = "asc"
	ReaderBookmarksGetManyParamsOrderDirectionDesc ReaderBookmarksGetManyParamsOrderDirection = "desc"
)

// Defines values for EbookGetManyParamsOrderDirection.
const (
	EbookGetManyParamsOrderDirectionAsc  EbookGetManyParamsOrderDirection = "asc"
	EbookGetManyParamsOrderDirectionDesc EbookGetManyParamsOrderDirection = "desc"
)

// Defines values for EbookStoreJSONBodyFormat.
const (
	Epub EbookStoreJSONBodyFormat = "epub"
	Pdf  EbookStoreJSONBodyFormat = "pdf"
	Txt  EbookStoreJSONBodyFormat = "txt"
)

// Defines values for ReaderReadingProgressGetManyParamsOrderDirection.
const (
	ReaderReadingProgressGetManyParamsOrderDirectionAsc  ReaderReadingProgressGetManyParamsOrderDirection = "asc"
	ReaderReadingProgressGetManyParamsOrderDirectionDesc ReaderReadingProgressGetManyParamsOrderDirection = "desc"
)

// Defines values for ReaderReadingProgressStoreJSONBodyReadingMode.
const (
	ReaderReadingProgressStoreJSONBodyReadingModeNormal ReaderReadingProgressStoreJSONBodyReadingMode = "normal"
	ReaderReadingProgressStoreJSONBodyReadingModeZen    ReaderReadingProgressStoreJSONBodyReadingMode = "zen"
)

// Defines values for ReaderReadingProgressUpdateJSONBodyReadingMode.
const (
	ReaderReadingProgressUpdateJSONBodyReadingModeNormal ReaderReadingProgressUpdateJSONBodyReadingMode = "normal"
	ReaderReadingProgressUpdateJSONBodyReadingModeZen    ReaderReadingProgressUpdateJSONBodyReadingMode = "zen"
)

// Defines values for ShareGetManyParamsOrderDirection.
const (
	ShareGetManyParamsOrderDirectionAsc  ShareGetManyParamsOrderDirection = "asc"
	ShareGetManyParamsOrderDirectionDesc ShareGetManyParamsOrderDirection = "desc"
)

// Defines values for ShareStoreJSONBodyStatus.
const (
	ShareStoreJSONBodyStatusActive   ShareStoreJSONBodyStatus = "active"
	ShareStoreJSONBodyStatusDisabled ShareStoreJSONBodyStatus = "disabled"
	ShareStoreJSONBodyStatusRemoved  ShareStoreJSONBodyStatus = "removed"
)

// Defines values for ShareStoreJSONBodyVisibility.
const (
	ShareStoreJSONBodyVisibilityPublic   ShareStoreJSONBodyVisibility = "public"
	ShareStoreJSONBodyVisibilityUnlisted ShareStoreJSONBodyVisibility = "unlisted"
)

// Defines values for ShareUpdateJSONBodyStatus.
const (
	ShareUpdateJSONBodyStatusActive   ShareUpdateJSONBodyStatus = "active"
	ShareUpdateJSONBodyStatusDisabled ShareUpdateJSONBodyStatus = "disabled"
	ShareUpdateJSONBodyStatusRemoved  ShareUpdateJSONBodyStatus = "removed"
)

// Defines values for ShareUpdateJSONBodyVisibility.
const (
	ShareUpdateJSONBodyVisibilityPublic   ShareUpdateJSONBodyVisibility = "public"
	ShareUpdateJSONBodyVisibilityUnlisted ShareUpdateJSONBodyVisibility = "unlisted"
)

// Defines values for ShareBorrowJSONBodyLegalAcknowledged.
const (
	True ShareBorrowJSONBodyLegalAcknowledged = true
)

// Defines values for ShareCreateReportJSONBodyReason.
const (
	Abuse     ShareCreateReportJSONBodyReason = "abuse"
	Copyright ShareCreateReportJSONBodyReason = "copyright"
	Other     ShareCreateReportJSONBodyReason = "other"
	Spam      ShareCreateReportJSONBodyReason = "spam"
)

// Defines values for SyncListEventsParamsOrderDirection.
const (
	SyncListEventsParamsOrderDirectionAsc  SyncListEventsParamsOrderDirection = "asc"
	SyncListEventsParamsOrderDirectionDesc SyncListEventsParamsOrderDirection = "desc"
)

// Defines values for SyncStoreEventJSONBodyEntityType.
const (
	Annotation  SyncStoreEventJSONBodyEntityType = "annotation"
	Bookmark    SyncStoreEventJSONBodyEntityType = "bookmark"
	Preference  SyncStoreEventJSONBodyEntityType = "preference"
	Progress    SyncStoreEventJSONBodyEntityType = "progress"
	ReaderState SyncStoreEventJSONBodyEntityType = "reader_state"
)

// Defines values for SyncStoreEventJSONBodyOperation.
const (
	Delete SyncStoreEventJSONBodyOperation = "delete"
	Upsert SyncStoreEventJSONBodyOperation = "upsert"
)

// Defines values for UserGetManyParamsOrderDirection.
const (
	Asc  UserGetManyParamsOrderDirection = "asc"
	Desc UserGetManyParamsOrderDirection = "desc"
)

// Defines values for ReaderPatchUserPreferencesJSONBodyReadingMode.
const (
	ReaderPatchUserPreferencesJSONBodyReadingModeNormal ReaderPatchUserPreferencesJSONBodyReadingMode = "normal"
	ReaderPatchUserPreferencesJSONBodyReadingModeZen    ReaderPatchUserPreferencesJSONBodyReadingMode = "zen"
)

// Defines values for ReaderPatchUserPreferencesJSONBodyThemeMode.
const (
	Dark         ReaderPatchUserPreferencesJSONBodyThemeMode = "dark"
	HighContrast ReaderPatchUserPreferencesJSONBodyThemeMode = "high_contrast"
	Light        ReaderPatchUserPreferencesJSONBodyThemeMode = "light"
	Sepia        ReaderPatchUserPreferencesJSONBodyThemeMode = "sepia"
)

// Defines values for ReaderPatchUserPreferencesJSONBodyTypographyProfile.
const (
	Comfortable ReaderPatchUserPreferencesJSONBodyTypographyProfile = "comfortable"
	Compact     ReaderPatchUserPreferencesJSONBodyTypographyProfile = "compact"
	Large       ReaderPatchUserPreferencesJSONBodyTypographyProfile = "large"
)

// Defines values for ReaderPatchUserReaderStateJSONBodyReadingMode.
const (
	ReaderPatchUserReaderStateJSONBodyReadingModeNormal ReaderPatchUserReaderStateJSONBodyReadingMode = "normal"
	ReaderPatchUserReaderStateJSONBodyReadingModeZen    ReaderPatchUserReaderStateJSONBodyReadingMode = "zen"
)

// ReaderAnnotationsGetManyParams defines parameters for ReaderAnnotationsGetMany.
type ReaderAnnotationsGetManyParams struct {
	Limit          *int                                          `form:"limit,omitempty" json:"limit,omitempty"`
	Offset         *int                                          `form:"offset,omitempty" json:"offset,omitempty"`
	Preloads       *string                                       `form:"preloads,omitempty" json:"preloads,omitempty"`
	OrderBy        *string                                       `form:"orderBy,omitempty" json:"orderBy,omitempty"`
	OrderDirection *ReaderAnnotationsGetManyParamsOrderDirection `form:"orderDirection,omitempty" json:"orderDirection,omitempty"`
}

// ReaderAnnotationsGetManyParamsOrderDirection defines parameters for ReaderAnnotationsGetMany.
type ReaderAnnotationsGetManyParamsOrderDirection string

// ReaderAnnotationsStoreJSONBody defines parameters for ReaderAnnotationsStore.
type ReaderAnnotationsStoreJSONBody struct {
	Color         *string            `json:"color,omitempty"`
	EbookId       openapi_types.UUID `json:"ebookId"`
	HighlightText *string            `json:"highlightText,omitempty"`
	LocationEnd   string             `json:"locationEnd"`
	LocationStart string             `json:"locationStart"`
	Note          *string            `json:"note,omitempty"`
}

// ReaderAnnotationsGetByIdParams defines parameters for ReaderAnnotationsGetById.
type ReaderAnnotationsGetByIdParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// ReaderAnnotationsUpdateJSONBody defines parameters for ReaderAnnotationsUpdate.
type ReaderAnnotationsUpdateJSONBody struct {
	Color         *string `json:"color,omitempty"`
	HighlightText *string `json:"highlightText,omitempty"`
	LocationEnd   *string `json:"locationEnd,omitempty"`
	LocationStart *string `json:"locationStart,omitempty"`
	Note          *string `json:"note,omitempty"`
}

// ReaderAnnotationsRestoreJSONBody defines parameters for ReaderAnnotationsRestore.
type ReaderAnnotationsRestoreJSONBody struct {
	Message *string `json:"message,omitempty"`
	Status  *int    `json:"status,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// ReaderAnnotationsRestoreParams defines parameters for ReaderAnnotationsRestore.
type ReaderAnnotationsRestoreParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// AuthGoogleCallbackParams defines parameters for AuthGoogleCallback.
type AuthGoogleCallbackParams struct {
	Code  string `form:"code" json:"code"`
	State string `form:"state" json:"state"`
}

// AuthGoogleDevicePollJSONBody defines parameters for AuthGoogleDevicePoll.
type AuthGoogleDevicePollJSONBody struct {
	DeviceCode string `json:"deviceCode"`
}

// AuthGoogleDeviceStartJSONBody defines parameters for AuthGoogleDeviceStart.
type AuthGoogleDeviceStartJSONBody = map[string]interface{}

// AuthLoginJSONBody defines parameters for AuthLogin.
type AuthLoginJSONBody struct {
	Identifier string `json:"identifier"`
	Password   string `json:"password"`
}

// AuthLogoutJSONBody defines parameters for AuthLogout.
type AuthLogoutJSONBody = map[string]interface{}

// AuthLogoutAllJSONBody defines parameters for AuthLogoutAll.
type AuthLogoutAllJSONBody = map[string]interface{}

// AuthRefreshJSONBody defines parameters for AuthRefresh.
type AuthRefreshJSONBody = map[string]interface{}

// AuthRegisterJSONBody defines parameters for AuthRegister.
type AuthRegisterJSONBody struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
	Username string              `json:"username"`
}

// AuthResendVerificationJSONBody defines parameters for AuthResendVerification.
type AuthResendVerificationJSONBody = map[string]interface{}

// AuthVerifyEmailJSONBody defines parameters for AuthVerifyEmail.
type AuthVerifyEmailJSONBody struct {
	Code  string              `json:"code"`
	Email openapi_types.Email `json:"email"`
}

// ReaderBookmarksGetManyParams defines parameters for ReaderBookmarksGetMany.
type ReaderBookmarksGetManyParams struct {
	Limit          *int                                        `form:"limit,omitempty" json:"limit,omitempty"`
	Offset         *int                                        `form:"offset,omitempty" json:"offset,omitempty"`
	Preloads       *string                                     `form:"preloads,omitempty" json:"preloads,omitempty"`
	OrderBy        *string                                     `form:"orderBy,omitempty" json:"orderBy,omitempty"`
	OrderDirection *ReaderBookmarksGetManyParamsOrderDirection `form:"orderDirection,omitempty" json:"orderDirection,omitempty"`
}

// ReaderBookmarksGetManyParamsOrderDirection defines parameters for ReaderBookmarksGetMany.
type ReaderBookmarksGetManyParamsOrderDirection string

// ReaderBookmarksStoreJSONBody defines parameters for ReaderBookmarksStore.
type ReaderBookmarksStoreJSONBody struct {
	EbookId  openapi_types.UUID `json:"ebookId"`
	Label    *string            `json:"label,omitempty"`
	Location string             `json:"location"`
}

// ReaderBookmarksGetByIdParams defines parameters for ReaderBookmarksGetById.
type ReaderBookmarksGetByIdParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// ReaderBookmarksUpdateJSONBody defines parameters for ReaderBookmarksUpdate.
type ReaderBookmarksUpdateJSONBody struct {
	Label *string `json:"label,omitempty"`
}

// ReaderBookmarksRestoreJSONBody defines parameters for ReaderBookmarksRestore.
type ReaderBookmarksRestoreJSONBody struct {
	Message *string `json:"message,omitempty"`
	Status  *int    `json:"status,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// ReaderBookmarksRestoreParams defines parameters for ReaderBookmarksRestore.
type ReaderBookmarksRestoreParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// ShareReturnBorrowJSONBody defines parameters for ShareReturnBorrow.
type ShareReturnBorrowJSONBody = map[string]interface{}

// EbookGetManyParams defines parameters for EbookGetMany.
type EbookGetManyParams struct {
	Limit          *int                              `form:"limit,omitempty" json:"limit,omitempty"`
	Offset         *int                              `form:"offset,omitempty" json:"offset,omitempty"`
	Preloads       *string                           `form:"preloads,omitempty" json:"preloads,omitempty"`
	OrderBy        *string                           `form:"orderBy,omitempty" json:"orderBy,omitempty"`
	OrderDirection *EbookGetManyParamsOrderDirection `form:"orderDirection,omitempty" json:"orderDirection,omitempty"`
}

// EbookGetManyParamsOrderDirection defines parameters for EbookGetMany.
type EbookGetManyParamsOrderDirection string

// EbookStoreJSONBody defines parameters for EbookStore.
type EbookStoreJSONBody struct {
	ChecksumSha256 string                   `json:"checksumSha256"`
	Description    *string                  `json:"description,omitempty"`
	FileSizeBytes  int                      `json:"fileSizeBytes"`
	Format         EbookStoreJSONBodyFormat `json:"format"`
	ImportedAt     *time.Time               `json:"importedAt,omitempty"`
	LanguageCode   *string                  `json:"languageCode,omitempty"`
	StorageKey     string                   `json:"storageKey"`
	Title          string                   `json:"title"`
}

// EbookStoreJSONBodyFormat defines parameters for EbookStore.
type EbookStoreJSONBodyFormat string

// EbookGetByIdParams defines parameters for EbookGetById.
type EbookGetByIdParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// EbookUpdateJSONBody defines parameters for EbookUpdate.
type EbookUpdateJSONBody struct {
	Description  *string `json:"description,omitempty"`
	LanguageCode *string `json:"languageCode,omitempty"`
	Title        *string `json:"title,omitempty"`
}

// EbookAttachMetadataJSONBody defines parameters for EbookAttachMetadata.
type EbookAttachMetadataJSONBody struct {
	Categories    *[]string                `json:"categories,omitempty"`
	GoogleBooksId string                   `json:"googleBooksId"`
	InfoLink      *string                  `json:"infoLink,omitempty"`
	Isbn10        *string                  `json:"isbn10,omitempty"`
	Isbn13        *string                  `json:"isbn13,omitempty"`
	PageCount     *int                     `json:"pageCount,omitempty"`
	PublishedDate *string                  `json:"publishedDate,omitempty"`
	Publisher     *string                  `json:"publisher,omitempty"`
	RawPayload    *map[string]*interface{} `json:"rawPayload,omitempty"`
	ThumbnailUrl  *string                  `json:"thumbnailUrl,omitempty"`
}

// EbookRestoreJSONBody defines parameters for EbookRestore.
type EbookRestoreJSONBody struct {
	Message *string `json:"message,omitempty"`
	Status  *int    `json:"status,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// EbookRestoreParams defines parameters for EbookRestore.
type EbookRestoreParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// ReaderReadingProgressGetManyParams defines parameters for ReaderReadingProgressGetMany.
type ReaderReadingProgressGetManyParams struct {
	Limit          *int                                              `form:"limit,omitempty" json:"limit,omitempty"`
	Offset         *int                                              `form:"offset,omitempty" json:"offset,omitempty"`
	Preloads       *string                                           `form:"preloads,omitempty" json:"preloads,omitempty"`
	OrderBy        *string                                           `form:"orderBy,omitempty" json:"orderBy,omitempty"`
	OrderDirection *ReaderReadingProgressGetManyParamsOrderDirection `form:"orderDirection,omitempty" json:"orderDirection,omitempty"`
}

// ReaderReadingProgressGetManyParamsOrderDirection defines parameters for ReaderReadingProgressGetMany.
type ReaderReadingProgressGetManyParamsOrderDirection string

// ReaderReadingProgressStoreJSONBody defines parameters for ReaderReadingProgressStore.
type ReaderReadingProgressStoreJSONBody struct {
	EbookId         openapi_types.UUID                            `json:"ebookId"`
	LastReadAt      *time.Time                                    `json:"lastReadAt,omitempty"`
	Location        string                                        `json:"location"`
	ProgressPercent *float32                                      `json:"progressPercent,omitempty"`
	ReadingMode     ReaderReadingProgressStoreJSONBodyReadingMode `json:"readingMode"`
}

// ReaderReadingProgressStoreJSONBodyReadingMode defines parameters for ReaderReadingProgressStore.
type ReaderReadingProgressStoreJSONBodyReadingMode string

// ReaderReadingProgressGetByIdParams defines parameters for ReaderReadingProgressGetById.
type ReaderReadingProgressGetByIdParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// ReaderReadingProgressUpdateJSONBody defines parameters for ReaderReadingProgressUpdate.
type ReaderReadingProgressUpdateJSONBody struct {
	LastReadAt      *time.Time                                      `json:"lastReadAt,omitempty"`
	Location        *string                                         `json:"location,omitempty"`
	ProgressPercent *float32                                        `json:"progressPercent,omitempty"`
	ReadingMode     *ReaderReadingProgressUpdateJSONBodyReadingMode `json:"readingMode,omitempty"`
}

// ReaderReadingProgressUpdateJSONBodyReadingMode defines parameters for ReaderReadingProgressUpdate.
type ReaderReadingProgressUpdateJSONBodyReadingMode string

// ReaderReadingProgressRestoreJSONBody defines parameters for ReaderReadingProgressRestore.
type ReaderReadingProgressRestoreJSONBody struct {
	Message *string `json:"message,omitempty"`
	Status  *int    `json:"status,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// ReaderReadingProgressRestoreParams defines parameters for ReaderReadingProgressRestore.
type ReaderReadingProgressRestoreParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// ShareGetManyParams defines parameters for ShareGetMany.
type ShareGetManyParams struct {
	Limit          *int                              `form:"limit,omitempty" json:"limit,omitempty"`
	Offset         *int                              `form:"offset,omitempty" json:"offset,omitempty"`
	Preloads       *string                           `form:"preloads,omitempty" json:"preloads,omitempty"`
	OrderBy        *string                           `form:"orderBy,omitempty" json:"orderBy,omitempty"`
	OrderDirection *ShareGetManyParamsOrderDirection `form:"orderDirection,omitempty" json:"orderDirection,omitempty"`
}

// ShareGetManyParamsOrderDirection defines parameters for ShareGetMany.
type ShareGetManyParamsOrderDirection string

// ShareStoreJSONBody defines parameters for ShareStore.
type ShareStoreJSONBody struct {
	BorrowDurationHours  int                           `json:"borrowDurationHours"`
	Description          *string                       `json:"description,omitempty"`
	EbookId              openapi_types.UUID            `json:"ebookId"`
	MaxConcurrentBorrows *int                          `json:"maxConcurrentBorrows,omitempty"`
	Status               *ShareStoreJSONBodyStatus     `json:"status,omitempty"`
	TitleOverride        *string                       `json:"titleOverride,omitempty"`
	Visibility           *ShareStoreJSONBodyVisibility `json:"visibility,omitempty"`
}

// ShareStoreJSONBodyStatus defines parameters for ShareStore.
type ShareStoreJSONBodyStatus string

// ShareStoreJSONBodyVisibility defines parameters for ShareStore.
type ShareStoreJSONBodyVisibility string

// ShareGetByIdParams defines parameters for ShareGetById.
type ShareGetByIdParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// ShareUpdateJSONBody defines parameters for ShareUpdate.
type ShareUpdateJSONBody struct {
	BorrowDurationHours  *int                           `json:"borrowDurationHours,omitempty"`
	Description          *string                        `json:"description,omitempty"`
	MaxConcurrentBorrows *int                           `json:"maxConcurrentBorrows,omitempty"`
	Status               *ShareUpdateJSONBodyStatus     `json:"status,omitempty"`
	TitleOverride        *string                        `json:"titleOverride,omitempty"`
	Visibility           *ShareUpdateJSONBodyVisibility `json:"visibility,omitempty"`
}

// ShareUpdateJSONBodyStatus defines parameters for ShareUpdate.
type ShareUpdateJSONBodyStatus string

// ShareUpdateJSONBodyVisibility defines parameters for ShareUpdate.
type ShareUpdateJSONBodyVisibility string

// ShareBorrowJSONBody defines parameters for ShareBorrow.
type ShareBorrowJSONBody struct {
	LegalAcknowledged ShareBorrowJSONBodyLegalAcknowledged `json:"legalAcknowledged"`
}

// ShareBorrowJSONBodyLegalAcknowledged defines parameters for ShareBorrow.
type ShareBorrowJSONBodyLegalAcknowledged bool

// ShareCreateReportJSONBody defines parameters for ShareCreateReport.
type ShareCreateReportJSONBody struct {
	Details *string                         `json:"details,omitempty"`
	Reason  ShareCreateReportJSONBodyReason `json:"reason"`
}

// ShareCreateReportJSONBodyReason defines parameters for ShareCreateReport.
type ShareCreateReportJSONBodyReason string

// ShareRestoreJSONBody defines parameters for ShareRestore.
type ShareRestoreJSONBody struct {
	Message *string `json:"message,omitempty"`
	Status  *int    `json:"status,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// ShareRestoreParams defines parameters for ShareRestore.
type ShareRestoreParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// ShareUpsertReviewJSONBody defines parameters for ShareUpsertReview.
type ShareUpsertReviewJSONBody struct {
	Rating     int     `json:"rating"`
	ReviewText *string `json:"reviewText,omitempty"`
}

// SyncListEventsParams defines parameters for SyncListEvents.
type SyncListEventsParams struct {
	Limit          *int                                `form:"limit,omitempty" json:"limit,omitempty"`
	Offset         *int                                `form:"offset,omitempty" json:"offset,omitempty"`
	Preloads       *string                             `form:"preloads,omitempty" json:"preloads,omitempty"`
	OrderBy        *string                             `form:"orderBy,omitempty" json:"orderBy,omitempty"`
	OrderDirection *SyncListEventsParamsOrderDirection `form:"orderDirection,omitempty" json:"orderDirection,omitempty"`
	Since          *time.Time                          `form:"since,omitempty" json:"since,omitempty"`
}

// SyncListEventsParamsOrderDirection defines parameters for SyncListEvents.
type SyncListEventsParamsOrderDirection string

// SyncStoreEventJSONBody defines parameters for SyncStoreEvent.
type SyncStoreEventJSONBody struct {
	BaseVersion     *int                             `json:"baseVersion,omitempty"`
	ClientTimestamp *time.Time                       `json:"clientTimestamp,omitempty"`
	EntityId        openapi_types.UUID               `json:"entityId"`
	EntityType      SyncStoreEventJSONBodyEntityType `json:"entityType"`
	IdempotencyKey  string                           `json:"idempotencyKey"`
	Operation       SyncStoreEventJSONBodyOperation  `json:"operation"`
	Payload         *map[string]*interface{}         `json:"payload,omitempty"`
}

// SyncStoreEventJSONBodyEntityType defines parameters for SyncStoreEvent.
type SyncStoreEventJSONBodyEntityType string

// SyncStoreEventJSONBodyOperation defines parameters for SyncStoreEvent.
type SyncStoreEventJSONBodyOperation string

// UserGetManyParams defines parameters for UserGetMany.
type UserGetManyParams struct {
	Limit          *int                             `form:"limit,omitempty" json:"limit,omitempty"`
	Offset         *int                             `form:"offset,omitempty" json:"offset,omitempty"`
	Preloads       *string                          `form:"preloads,omitempty" json:"preloads,omitempty"`
	OrderBy        *string                          `form:"orderBy,omitempty" json:"orderBy,omitempty"`
	OrderDirection *UserGetManyParamsOrderDirection `form:"orderDirection,omitempty" json:"orderDirection,omitempty"`
}

// UserGetManyParamsOrderDirection defines parameters for UserGetMany.
type UserGetManyParamsOrderDirection string

// UserStoreJSONBody defines parameters for UserStore.
type UserStoreJSONBody struct {
	Email    openapi_types.Email `json:"email"`
	GoogleId *string             `json:"googleId,omitempty"`
	Password string              `json:"password"`
	Username string              `json:"username"`
}

// ReaderPatchUserPreferencesJSONBody defines parameters for ReaderPatchUserPreferences.
type ReaderPatchUserPreferencesJSONBody struct {
	ReadingMode       *ReaderPatchUserPreferencesJSONBodyReadingMode       `json:"readingMode,omitempty"`
	ThemeMode         *ReaderPatchUserPreferencesJSONBodyThemeMode         `json:"themeMode,omitempty"`
	ThemeOverrides    *map[string]string                                   `json:"themeOverrides,omitempty"`
	TypographyProfile *ReaderPatchUserPreferencesJSONBodyTypographyProfile `json:"typographyProfile,omitempty"`
	ZenRestoreOnOpen  *bool                                                `json:"zenRestoreOnOpen,omitempty"`
}

// ReaderPatchUserPreferencesJSONBodyReadingMode defines parameters for ReaderPatchUserPreferences.
type ReaderPatchUserPreferencesJSONBodyReadingMode string

// ReaderPatchUserPreferencesJSONBodyThemeMode defines parameters for ReaderPatchUserPreferences.
type ReaderPatchUserPreferencesJSONBodyThemeMode string

// ReaderPatchUserPreferencesJSONBodyTypographyProfile defines parameters for ReaderPatchUserPreferences.
type ReaderPatchUserPreferencesJSONBodyTypographyProfile string

// ReaderPatchUserReaderStateJSONBody defines parameters for ReaderPatchUserReaderState.
type ReaderPatchUserReaderStateJSONBody struct {
	CurrentEbookId  *openapi_types.UUID                            `json:"currentEbookId,omitempty"`
	CurrentLocation *string                                        `json:"currentLocation,omitempty"`
	LastOpenedAt    *time.Time                                     `json:"lastOpenedAt,omitempty"`
	ReadingMode     *ReaderPatchUserReaderStateJSONBodyReadingMode `json:"readingMode,omitempty"`
}

// ReaderPatchUserReaderStateJSONBodyReadingMode defines parameters for ReaderPatchUserReaderState.
type ReaderPatchUserReaderStateJSONBodyReadingMode string

// UserGetByIdParams defines parameters for UserGetById.
type UserGetByIdParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// UserUpdateJSONBody defines parameters for UserUpdate.
type UserUpdateJSONBody struct {
	Email    openapi_types.Email `json:"email"`
	Username string              `json:"username"`
}

// UserRestoreJSONBody defines parameters for UserRestore.
type UserRestoreJSONBody struct {
	Message *string `json:"message,omitempty"`
	Status  *int    `json:"status,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// UserRestoreParams defines parameters for UserRestore.
type UserRestoreParams struct {
	Preloads *string `form:"preloads,omitempty" json:"preloads,omitempty"`
}

// ReaderAnnotationsStoreJSONRequestBody defines body for ReaderAnnotationsStore for application/json ContentType.
type ReaderAnnotationsStoreJSONRequestBody ReaderAnnotationsStoreJSONBody

// ReaderAnnotationsUpdateJSONRequestBody defines body for ReaderAnnotationsUpdate for application/json ContentType.
type ReaderAnnotationsUpdateJSONRequestBody ReaderAnnotationsUpdateJSONBody

// ReaderAnnotationsRestoreJSONRequestBody defines body for ReaderAnnotationsRestore for application/json ContentType.
type ReaderAnnotationsRestoreJSONRequestBody ReaderAnnotationsRestoreJSONBody

// AuthGoogleDevicePollJSONRequestBody defines body for AuthGoogleDevicePoll for application/json ContentType.
type AuthGoogleDevicePollJSONRequestBody AuthGoogleDevicePollJSONBody

// AuthGoogleDeviceStartJSONRequestBody defines body for AuthGoogleDeviceStart for application/json ContentType.
type AuthGoogleDeviceStartJSONRequestBody = AuthGoogleDeviceStartJSONBody

// AuthLoginJSONRequestBody defines body for AuthLogin for application/json ContentType.
type AuthLoginJSONRequestBody AuthLoginJSONBody

// AuthLogoutJSONRequestBody defines body for AuthLogout for application/json ContentType.
type AuthLogoutJSONRequestBody = AuthLogoutJSONBody

// AuthLogoutAllJSONRequestBody defines body for AuthLogoutAll for application/json ContentType.
type AuthLogoutAllJSONRequestBody = AuthLogoutAllJSONBody

// AuthRefreshJSONRequestBody defines body for AuthRefresh for application/json ContentType.
type AuthRefreshJSONRequestBody = AuthRefreshJSONBody

// AuthRegisterJSONRequestBody defines body for AuthRegister for application/json ContentType.
type AuthRegisterJSONRequestBody AuthRegisterJSONBody

// AuthResendVerificationJSONRequestBody defines body for AuthResendVerification for application/json ContentType.
type AuthResendVerificationJSONRequestBody = AuthResendVerificationJSONBody

// AuthVerifyEmailJSONRequestBody defines body for AuthVerifyEmail for application/json ContentType.
type AuthVerifyEmailJSONRequestBody AuthVerifyEmailJSONBody

// ReaderBookmarksStoreJSONRequestBody defines body for ReaderBookmarksStore for application/json ContentType.
type ReaderBookmarksStoreJSONRequestBody ReaderBookmarksStoreJSONBody

// ReaderBookmarksUpdateJSONRequestBody defines body for ReaderBookmarksUpdate for application/json ContentType.
type ReaderBookmarksUpdateJSONRequestBody ReaderBookmarksUpdateJSONBody

// ReaderBookmarksRestoreJSONRequestBody defines body for ReaderBookmarksRestore for application/json ContentType.
type ReaderBookmarksRestoreJSONRequestBody ReaderBookmarksRestoreJSONBody

// ShareReturnBorrowJSONRequestBody defines body for ShareReturnBorrow for application/json ContentType.
type ShareReturnBorrowJSONRequestBody = ShareReturnBorrowJSONBody

// EbookStoreJSONRequestBody defines body for EbookStore for application/json ContentType.
type EbookStoreJSONRequestBody EbookStoreJSONBody

// EbookUpdateJSONRequestBody defines body for EbookUpdate for application/json ContentType.
type EbookUpdateJSONRequestBody EbookUpdateJSONBody

// EbookAttachMetadataJSONRequestBody defines body for EbookAttachMetadata for application/json ContentType.
type EbookAttachMetadataJSONRequestBody EbookAttachMetadataJSONBody

// EbookRestoreJSONRequestBody defines body for EbookRestore for application/json ContentType.
type EbookRestoreJSONRequestBody EbookRestoreJSONBody

// ReaderReadingProgressStoreJSONRequestBody defines body for ReaderReadingProgressStore for application/json ContentType.
type ReaderReadingProgressStoreJSONRequestBody ReaderReadingProgressStoreJSONBody

// ReaderReadingProgressUpdateJSONRequestBody defines body for ReaderReadingProgressUpdate for application/json ContentType.
type ReaderReadingProgressUpdateJSONRequestBody ReaderReadingProgressUpdateJSONBody

// ReaderReadingProgressRestoreJSONRequestBody defines body for ReaderReadingProgressRestore for application/json ContentType.
type ReaderReadingProgressRestoreJSONRequestBody ReaderReadingProgressRestoreJSONBody

// ShareStoreJSONRequestBody defines body for ShareStore for application/json ContentType.
type ShareStoreJSONRequestBody ShareStoreJSONBody

// ShareUpdateJSONRequestBody defines body for ShareUpdate for application/json ContentType.
type ShareUpdateJSONRequestBody ShareUpdateJSONBody

// ShareBorrowJSONRequestBody defines body for ShareBorrow for application/json ContentType.
type ShareBorrowJSONRequestBody ShareBorrowJSONBody

// ShareCreateReportJSONRequestBody defines body for ShareCreateReport for application/json ContentType.
type ShareCreateReportJSONRequestBody ShareCreateReportJSONBody

// ShareRestoreJSONRequestBody defines body for ShareRestore for application/json ContentType.
type ShareRestoreJSONRequestBody ShareRestoreJSONBody

// ShareUpsertReviewJSONRequestBody defines body for ShareUpsertReview for application/json ContentType.
type ShareUpsertReviewJSONRequestBody ShareUpsertReviewJSONBody

// SyncStoreEventJSONRequestBody defines body for SyncStoreEvent for application/json ContentType.
type SyncStoreEventJSONRequestBody SyncStoreEventJSONBody

// UserStoreJSONRequestBody defines body for UserStore for application/json ContentType.
type UserStoreJSONRequestBody UserStoreJSONBody

// ReaderPatchUserPreferencesJSONRequestBody defines body for ReaderPatchUserPreferences for application/json ContentType.
type ReaderPatchUserPreferencesJSONRequestBody ReaderPatchUserPreferencesJSONBody

// ReaderPatchUserReaderStateJSONRequestBody defines body for ReaderPatchUserReaderState for application/json ContentType.
type ReaderPatchUserReaderStateJSONRequestBody ReaderPatchUserReaderStateJSONBody

// UserUpdateJSONRequestBody defines body for UserUpdate for application/json ContentType.
type UserUpdateJSONRequestBody UserUpdateJSONBody

// UserRestoreJSONRequestBody defines body for UserRestore for application/json ContentType.
type UserRestoreJSONRequestBody UserRestoreJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ReaderAnnotationsGetMany request
	ReaderAnnotationsGetMany(ctx context.Context, params *ReaderAnnotationsGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderAnnotationsStoreWithBody request with any body
	ReaderAnnotationsStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderAnnotationsStore(ctx context.Context, body ReaderAnnotationsStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderAnnotationsDestroy request
	ReaderAnnotationsDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderAnnotationsGetById request
	ReaderAnnotationsGetById(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderAnnotationsUpdateWithBody request with any body
	ReaderAnnotationsUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderAnnotationsUpdate(ctx context.Context, id openapi_types.UUID, body ReaderAnnotationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderAnnotationsKill request
	ReaderAnnotationsKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderAnnotationsRestoreWithBody request with any body
	ReaderAnnotationsRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderAnnotationsRestore(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, body ReaderAnnotationsRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthGoogleLogin request
	AuthGoogleLogin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthGoogleCallback request
	AuthGoogleCallback(ctx context.Context, params *AuthGoogleCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthGoogleDevicePollWithBody request with any body
	AuthGoogleDevicePollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthGoogleDevicePoll(ctx context.Context, body AuthGoogleDevicePollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthGoogleDeviceStartWithBody request with any body
	AuthGoogleDeviceStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthGoogleDeviceStart(ctx context.Context, body AuthGoogleDeviceStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLoginWithBody request with any body
	AuthLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthLogin(ctx context.Context, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLogoutWithBody request with any body
	AuthLogoutWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthLogout(ctx context.Context, body AuthLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLogoutAllWithBody request with any body
	AuthLogoutAllWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthLogoutAll(ctx context.Context, body AuthLogoutAllJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthMe request
	AuthMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthRefreshWithBody request with any body
	AuthRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthRefresh(ctx context.Context, body AuthRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthRegisterWithBody request with any body
	AuthRegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthRegister(ctx context.Context, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthResendVerificationWithBody request with any body
	AuthResendVerificationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthResendVerification(ctx context.Context, body AuthResendVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthVerifyEmailWithBody request with any body
	AuthVerifyEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthVerifyEmail(ctx context.Context, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderBookmarksGetMany request
	ReaderBookmarksGetMany(ctx context.Context, params *ReaderBookmarksGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderBookmarksStoreWithBody request with any body
	ReaderBookmarksStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderBookmarksStore(ctx context.Context, body ReaderBookmarksStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderBookmarksDestroy request
	ReaderBookmarksDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderBookmarksGetById request
	ReaderBookmarksGetById(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderBookmarksUpdateWithBody request with any body
	ReaderBookmarksUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderBookmarksUpdate(ctx context.Context, id openapi_types.UUID, body ReaderBookmarksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderBookmarksKill request
	ReaderBookmarksKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderBookmarksRestoreWithBody request with any body
	ReaderBookmarksRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderBookmarksRestore(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, body ReaderBookmarksRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareReturnBorrowWithBody request with any body
	ShareReturnBorrowWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShareReturnBorrow(ctx context.Context, id openapi_types.UUID, body ShareReturnBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EbookGetMany request
	EbookGetMany(ctx context.Context, params *EbookGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EbookStoreWithBody request with any body
	EbookStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EbookStore(ctx context.Context, body EbookStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EbookDestroy request
	EbookDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EbookGetById request
	EbookGetById(ctx context.Context, id openapi_types.UUID, params *EbookGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EbookUpdateWithBody request with any body
	EbookUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EbookUpdate(ctx context.Context, id openapi_types.UUID, body EbookUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EbookKill request
	EbookKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EbookRemoveMetadata request
	EbookRemoveMetadata(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EbookAttachMetadataWithBody request with any body
	EbookAttachMetadataWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EbookAttachMetadata(ctx context.Context, id openapi_types.UUID, body EbookAttachMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EbookRestoreWithBody request with any body
	EbookRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *EbookRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EbookRestore(ctx context.Context, id openapi_types.UUID, params *EbookRestoreParams, body EbookRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderReadingProgressGetMany request
	ReaderReadingProgressGetMany(ctx context.Context, params *ReaderReadingProgressGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderReadingProgressStoreWithBody request with any body
	ReaderReadingProgressStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderReadingProgressStore(ctx context.Context, body ReaderReadingProgressStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderReadingProgressDestroy request
	ReaderReadingProgressDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderReadingProgressGetById request
	ReaderReadingProgressGetById(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderReadingProgressUpdateWithBody request with any body
	ReaderReadingProgressUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderReadingProgressUpdate(ctx context.Context, id openapi_types.UUID, body ReaderReadingProgressUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderReadingProgressKill request
	ReaderReadingProgressKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderReadingProgressRestoreWithBody request with any body
	ReaderReadingProgressRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderReadingProgressRestore(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, body ReaderReadingProgressRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareGetMany request
	ShareGetMany(ctx context.Context, params *ShareGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareStoreWithBody request with any body
	ShareStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShareStore(ctx context.Context, body ShareStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareDestroy request
	ShareDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareGetById request
	ShareGetById(ctx context.Context, id openapi_types.UUID, params *ShareGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareUpdateWithBody request with any body
	ShareUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShareUpdate(ctx context.Context, id openapi_types.UUID, body ShareUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareBorrowWithBody request with any body
	ShareBorrowWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShareBorrow(ctx context.Context, id openapi_types.UUID, body ShareBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareKill request
	ShareKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareCreateReportWithBody request with any body
	ShareCreateReportWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShareCreateReport(ctx context.Context, id openapi_types.UUID, body ShareCreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareRestoreWithBody request with any body
	ShareRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *ShareRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShareRestore(ctx context.Context, id openapi_types.UUID, params *ShareRestoreParams, body ShareRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareUpsertReviewWithBody request with any body
	ShareUpsertReviewWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShareUpsertReview(ctx context.Context, id openapi_types.UUID, body ShareUpsertReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncListEvents request
	SyncListEvents(ctx context.Context, params *SyncListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncStoreEventWithBody request with any body
	SyncStoreEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncStoreEvent(ctx context.Context, body SyncStoreEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserGetMany request
	UserGetMany(ctx context.Context, params *UserGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserStoreWithBody request with any body
	UserStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserStore(ctx context.Context, body UserStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderGetUserPreferences request
	ReaderGetUserPreferences(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderPatchUserPreferencesWithBody request with any body
	ReaderPatchUserPreferencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderPatchUserPreferences(ctx context.Context, body ReaderPatchUserPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderGetUserReaderState request
	ReaderGetUserReaderState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReaderPatchUserReaderStateWithBody request with any body
	ReaderPatchUserReaderStateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReaderPatchUserReaderState(ctx context.Context, body ReaderPatchUserReaderStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserDestroy request
	UserDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserGetById request
	UserGetById(ctx context.Context, id openapi_types.UUID, params *UserGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateWithBody request with any body
	UserUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdate(ctx context.Context, id openapi_types.UUID, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserKill request
	UserKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserRestoreWithBody request with any body
	UserRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *UserRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserRestore(ctx context.Context, id openapi_types.UUID, params *UserRestoreParams, body UserRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthGetHealth request
	HealthGetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ReaderAnnotationsGetMany(ctx context.Context, params *ReaderAnnotationsGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsGetManyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderAnnotationsStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderAnnotationsStore(ctx context.Context, body ReaderAnnotationsStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderAnnotationsDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderAnnotationsGetById(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsGetByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderAnnotationsUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderAnnotationsUpdate(ctx context.Context, id openapi_types.UUID, body ReaderAnnotationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderAnnotationsKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsKillRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderAnnotationsRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsRestoreRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderAnnotationsRestore(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, body ReaderAnnotationsRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderAnnotationsRestoreRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthGoogleLogin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthGoogleLoginRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthGoogleCallback(ctx context.Context, params *AuthGoogleCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthGoogleCallbackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthGoogleDevicePollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthGoogleDevicePollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthGoogleDevicePoll(ctx context.Context, body AuthGoogleDevicePollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthGoogleDevicePollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthGoogleDeviceStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthGoogleDeviceStartRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthGoogleDeviceStart(ctx context.Context, body AuthGoogleDeviceStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthGoogleDeviceStartRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogin(ctx context.Context, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogoutWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLogoutRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogout(ctx context.Context, body AuthLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLogoutRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogoutAllWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLogoutAllRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogoutAll(ctx context.Context, body AuthLogoutAllJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLogoutAllRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRefreshRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRefresh(ctx context.Context, body AuthRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRefreshRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRegisterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRegister(ctx context.Context, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRegisterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthResendVerificationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthResendVerificationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthResendVerification(ctx context.Context, body AuthResendVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthResendVerificationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthVerifyEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthVerifyEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthVerifyEmail(ctx context.Context, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthVerifyEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksGetMany(ctx context.Context, params *ReaderBookmarksGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksGetManyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksStore(ctx context.Context, body ReaderBookmarksStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksGetById(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksGetByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksUpdate(ctx context.Context, id openapi_types.UUID, body ReaderBookmarksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksKillRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksRestoreRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderBookmarksRestore(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, body ReaderBookmarksRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderBookmarksRestoreRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareReturnBorrowWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareReturnBorrowRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareReturnBorrow(ctx context.Context, id openapi_types.UUID, body ShareReturnBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareReturnBorrowRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookGetMany(ctx context.Context, params *EbookGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookGetManyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookStore(ctx context.Context, body EbookStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookGetById(ctx context.Context, id openapi_types.UUID, params *EbookGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookGetByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookUpdate(ctx context.Context, id openapi_types.UUID, body EbookUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookKillRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookRemoveMetadata(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookRemoveMetadataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookAttachMetadataWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookAttachMetadataRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookAttachMetadata(ctx context.Context, id openapi_types.UUID, body EbookAttachMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookAttachMetadataRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *EbookRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookRestoreRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EbookRestore(ctx context.Context, id openapi_types.UUID, params *EbookRestoreParams, body EbookRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEbookRestoreRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressGetMany(ctx context.Context, params *ReaderReadingProgressGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressGetManyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressStore(ctx context.Context, body ReaderReadingProgressStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressGetById(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressGetByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressUpdate(ctx context.Context, id openapi_types.UUID, body ReaderReadingProgressUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressKillRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressRestoreRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderReadingProgressRestore(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, body ReaderReadingProgressRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderReadingProgressRestoreRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareGetMany(ctx context.Context, params *ShareGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareGetManyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareStore(ctx context.Context, body ShareStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareGetById(ctx context.Context, id openapi_types.UUID, params *ShareGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareGetByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareUpdate(ctx context.Context, id openapi_types.UUID, body ShareUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareBorrowWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareBorrowRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareBorrow(ctx context.Context, id openapi_types.UUID, body ShareBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareBorrowRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareKillRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareCreateReportWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareCreateReportRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareCreateReport(ctx context.Context, id openapi_types.UUID, body ShareCreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareCreateReportRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *ShareRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareRestoreRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareRestore(ctx context.Context, id openapi_types.UUID, params *ShareRestoreParams, body ShareRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareRestoreRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareUpsertReviewWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareUpsertReviewRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareUpsertReview(ctx context.Context, id openapi_types.UUID, body ShareUpsertReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareUpsertReviewRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncListEvents(ctx context.Context, params *SyncListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncListEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncStoreEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncStoreEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncStoreEvent(ctx context.Context, body SyncStoreEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncStoreEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserGetMany(ctx context.Context, params *UserGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserGetManyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserStore(ctx context.Context, body UserStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderGetUserPreferences(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderGetUserPreferencesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderPatchUserPreferencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderPatchUserPreferencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderPatchUserPreferences(ctx context.Context, body ReaderPatchUserPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderPatchUserPreferencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderGetUserReaderState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderGetUserReaderStateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderPatchUserReaderStateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderPatchUserReaderStateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReaderPatchUserReaderState(ctx context.Context, body ReaderPatchUserReaderStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReaderPatchUserReaderStateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserDestroy(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserGetById(ctx context.Context, id openapi_types.UUID, params *UserGetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserGetByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdate(ctx context.Context, id openapi_types.UUID, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserKill(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserKillRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserRestoreWithBody(ctx context.Context, id openapi_types.UUID, params *UserRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserRestoreRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserRestore(ctx context.Context, id openapi_types.UUID, params *UserRestoreParams, body UserRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserRestoreRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthGetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewReaderAnnotationsGetManyRequest generates requests for ReaderAnnotationsGetMany
func NewReaderAnnotationsGetManyRequest(server string, params *ReaderAnnotationsGetManyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/annotations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderDirection", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderAnnotationsStoreRequest calls the generic ReaderAnnotationsStore builder with application/json body
func NewReaderAnnotationsStoreRequest(server string, body ReaderAnnotationsStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderAnnotationsStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewReaderAnnotationsStoreRequestWithBody generates requests for ReaderAnnotationsStore with any type of body
func NewReaderAnnotationsStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/annotations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderAnnotationsDestroyRequest generates requests for ReaderAnnotationsDestroy
func NewReaderAnnotationsDestroyRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/annotations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderAnnotationsGetByIdRequest generates requests for ReaderAnnotationsGetById
func NewReaderAnnotationsGetByIdRequest(server string, id openapi_types.UUID, params *ReaderAnnotationsGetByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/annotations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderAnnotationsUpdateRequest calls the generic ReaderAnnotationsUpdate builder with application/json body
func NewReaderAnnotationsUpdateRequest(server string, id openapi_types.UUID, body ReaderAnnotationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderAnnotationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReaderAnnotationsUpdateRequestWithBody generates requests for ReaderAnnotationsUpdate with any type of body
func NewReaderAnnotationsUpdateRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/annotations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderAnnotationsKillRequest generates requests for ReaderAnnotationsKill
func NewReaderAnnotationsKillRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/annotations/%s/kill", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderAnnotationsRestoreRequest calls the generic ReaderAnnotationsRestore builder with application/json body
func NewReaderAnnotationsRestoreRequest(server string, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, body ReaderAnnotationsRestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderAnnotationsRestoreRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewReaderAnnotationsRestoreRequestWithBody generates requests for ReaderAnnotationsRestore with any type of body
func NewReaderAnnotationsRestoreRequestWithBody(server string, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/annotations/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthGoogleLoginRequest generates requests for AuthGoogleLogin
func NewAuthGoogleLoginRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/google")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthGoogleCallbackRequest generates requests for AuthGoogleCallback
func NewAuthGoogleCallbackRequest(server string, params *AuthGoogleCallbackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/google/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthGoogleDevicePollRequest calls the generic AuthGoogleDevicePoll builder with application/json body
func NewAuthGoogleDevicePollRequest(server string, body AuthGoogleDevicePollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthGoogleDevicePollRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthGoogleDevicePollRequestWithBody generates requests for AuthGoogleDevicePoll with any type of body
func NewAuthGoogleDevicePollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/google/device/poll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthGoogleDeviceStartRequest calls the generic AuthGoogleDeviceStart builder with application/json body
func NewAuthGoogleDeviceStartRequest(server string, body AuthGoogleDeviceStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthGoogleDeviceStartRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthGoogleDeviceStartRequestWithBody generates requests for AuthGoogleDeviceStart with any type of body
func NewAuthGoogleDeviceStartRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/google/device/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthLoginRequest calls the generic AuthLogin builder with application/json body
func NewAuthLoginRequest(server string, body AuthLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthLoginRequestWithBody generates requests for AuthLogin with any type of body
func NewAuthLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthLogoutRequest calls the generic AuthLogout builder with application/json body
func NewAuthLogoutRequest(server string, body AuthLogoutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthLogoutRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthLogoutRequestWithBody generates requests for AuthLogout with any type of body
func NewAuthLogoutRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthLogoutAllRequest calls the generic AuthLogoutAll builder with application/json body
func NewAuthLogoutAllRequest(server string, body AuthLogoutAllJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthLogoutAllRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthLogoutAllRequestWithBody generates requests for AuthLogoutAll with any type of body
func NewAuthLogoutAllRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/logout-all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthMeRequest generates requests for AuthMe
func NewAuthMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthRefreshRequest calls the generic AuthRefresh builder with application/json body
func NewAuthRefreshRequest(server string, body AuthRefreshJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthRefreshRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthRefreshRequestWithBody generates requests for AuthRefresh with any type of body
func NewAuthRefreshRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthRegisterRequest calls the generic AuthRegister builder with application/json body
func NewAuthRegisterRequest(server string, body AuthRegisterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthRegisterRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthRegisterRequestWithBody generates requests for AuthRegister with any type of body
func NewAuthRegisterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthResendVerificationRequest calls the generic AuthResendVerification builder with application/json body
func NewAuthResendVerificationRequest(server string, body AuthResendVerificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthResendVerificationRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthResendVerificationRequestWithBody generates requests for AuthResendVerification with any type of body
func NewAuthResendVerificationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/resend-verification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthVerifyEmailRequest calls the generic AuthVerifyEmail builder with application/json body
func NewAuthVerifyEmailRequest(server string, body AuthVerifyEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthVerifyEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthVerifyEmailRequestWithBody generates requests for AuthVerifyEmail with any type of body
func NewAuthVerifyEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/verify-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderBookmarksGetManyRequest generates requests for ReaderBookmarksGetMany
func NewReaderBookmarksGetManyRequest(server string, params *ReaderBookmarksGetManyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/bookmarks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderDirection", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderBookmarksStoreRequest calls the generic ReaderBookmarksStore builder with application/json body
func NewReaderBookmarksStoreRequest(server string, body ReaderBookmarksStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderBookmarksStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewReaderBookmarksStoreRequestWithBody generates requests for ReaderBookmarksStore with any type of body
func NewReaderBookmarksStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/bookmarks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderBookmarksDestroyRequest generates requests for ReaderBookmarksDestroy
func NewReaderBookmarksDestroyRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/bookmarks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderBookmarksGetByIdRequest generates requests for ReaderBookmarksGetById
func NewReaderBookmarksGetByIdRequest(server string, id openapi_types.UUID, params *ReaderBookmarksGetByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/bookmarks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderBookmarksUpdateRequest calls the generic ReaderBookmarksUpdate builder with application/json body
func NewReaderBookmarksUpdateRequest(server string, id openapi_types.UUID, body ReaderBookmarksUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderBookmarksUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReaderBookmarksUpdateRequestWithBody generates requests for ReaderBookmarksUpdate with any type of body
func NewReaderBookmarksUpdateRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/bookmarks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderBookmarksKillRequest generates requests for ReaderBookmarksKill
func NewReaderBookmarksKillRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/bookmarks/%s/kill", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderBookmarksRestoreRequest calls the generic ReaderBookmarksRestore builder with application/json body
func NewReaderBookmarksRestoreRequest(server string, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, body ReaderBookmarksRestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderBookmarksRestoreRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewReaderBookmarksRestoreRequestWithBody generates requests for ReaderBookmarksRestore with any type of body
func NewReaderBookmarksRestoreRequestWithBody(server string, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/bookmarks/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShareReturnBorrowRequest calls the generic ShareReturnBorrow builder with application/json body
func NewShareReturnBorrowRequest(server string, id openapi_types.UUID, body ShareReturnBorrowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareReturnBorrowRequestWithBody(server, id, "application/json", bodyReader)
}

// NewShareReturnBorrowRequestWithBody generates requests for ShareReturnBorrow with any type of body
func NewShareReturnBorrowRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/borrows/%s/return", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEbookGetManyRequest generates requests for EbookGetMany
func NewEbookGetManyRequest(server string, params *EbookGetManyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ebooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderDirection", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEbookStoreRequest calls the generic EbookStore builder with application/json body
func NewEbookStoreRequest(server string, body EbookStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEbookStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewEbookStoreRequestWithBody generates requests for EbookStore with any type of body
func NewEbookStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ebooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEbookDestroyRequest generates requests for EbookDestroy
func NewEbookDestroyRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ebooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEbookGetByIdRequest generates requests for EbookGetById
func NewEbookGetByIdRequest(server string, id openapi_types.UUID, params *EbookGetByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ebooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEbookUpdateRequest calls the generic EbookUpdate builder with application/json body
func NewEbookUpdateRequest(server string, id openapi_types.UUID, body EbookUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEbookUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEbookUpdateRequestWithBody generates requests for EbookUpdate with any type of body
func NewEbookUpdateRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ebooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEbookKillRequest generates requests for EbookKill
func NewEbookKillRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ebooks/%s/kill", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEbookRemoveMetadataRequest generates requests for EbookRemoveMetadata
func NewEbookRemoveMetadataRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ebooks/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEbookAttachMetadataRequest calls the generic EbookAttachMetadata builder with application/json body
func NewEbookAttachMetadataRequest(server string, id openapi_types.UUID, body EbookAttachMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEbookAttachMetadataRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEbookAttachMetadataRequestWithBody generates requests for EbookAttachMetadata with any type of body
func NewEbookAttachMetadataRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ebooks/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEbookRestoreRequest calls the generic EbookRestore builder with application/json body
func NewEbookRestoreRequest(server string, id openapi_types.UUID, params *EbookRestoreParams, body EbookRestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEbookRestoreRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewEbookRestoreRequestWithBody generates requests for EbookRestore with any type of body
func NewEbookRestoreRequestWithBody(server string, id openapi_types.UUID, params *EbookRestoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ebooks/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderReadingProgressGetManyRequest generates requests for ReaderReadingProgressGetMany
func NewReaderReadingProgressGetManyRequest(server string, params *ReaderReadingProgressGetManyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reading-progress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderDirection", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderReadingProgressStoreRequest calls the generic ReaderReadingProgressStore builder with application/json body
func NewReaderReadingProgressStoreRequest(server string, body ReaderReadingProgressStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderReadingProgressStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewReaderReadingProgressStoreRequestWithBody generates requests for ReaderReadingProgressStore with any type of body
func NewReaderReadingProgressStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reading-progress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderReadingProgressDestroyRequest generates requests for ReaderReadingProgressDestroy
func NewReaderReadingProgressDestroyRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reading-progress/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderReadingProgressGetByIdRequest generates requests for ReaderReadingProgressGetById
func NewReaderReadingProgressGetByIdRequest(server string, id openapi_types.UUID, params *ReaderReadingProgressGetByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reading-progress/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderReadingProgressUpdateRequest calls the generic ReaderReadingProgressUpdate builder with application/json body
func NewReaderReadingProgressUpdateRequest(server string, id openapi_types.UUID, body ReaderReadingProgressUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderReadingProgressUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReaderReadingProgressUpdateRequestWithBody generates requests for ReaderReadingProgressUpdate with any type of body
func NewReaderReadingProgressUpdateRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reading-progress/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderReadingProgressKillRequest generates requests for ReaderReadingProgressKill
func NewReaderReadingProgressKillRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reading-progress/%s/kill", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderReadingProgressRestoreRequest calls the generic ReaderReadingProgressRestore builder with application/json body
func NewReaderReadingProgressRestoreRequest(server string, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, body ReaderReadingProgressRestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderReadingProgressRestoreRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewReaderReadingProgressRestoreRequestWithBody generates requests for ReaderReadingProgressRestore with any type of body
func NewReaderReadingProgressRestoreRequestWithBody(server string, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reading-progress/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShareGetManyRequest generates requests for ShareGetMany
func NewShareGetManyRequest(server string, params *ShareGetManyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderDirection", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShareStoreRequest calls the generic ShareStore builder with application/json body
func NewShareStoreRequest(server string, body ShareStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewShareStoreRequestWithBody generates requests for ShareStore with any type of body
func NewShareStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShareDestroyRequest generates requests for ShareDestroy
func NewShareDestroyRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShareGetByIdRequest generates requests for ShareGetById
func NewShareGetByIdRequest(server string, id openapi_types.UUID, params *ShareGetByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShareUpdateRequest calls the generic ShareUpdate builder with application/json body
func NewShareUpdateRequest(server string, id openapi_types.UUID, body ShareUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewShareUpdateRequestWithBody generates requests for ShareUpdate with any type of body
func NewShareUpdateRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShareBorrowRequest calls the generic ShareBorrow builder with application/json body
func NewShareBorrowRequest(server string, id openapi_types.UUID, body ShareBorrowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareBorrowRequestWithBody(server, id, "application/json", bodyReader)
}

// NewShareBorrowRequestWithBody generates requests for ShareBorrow with any type of body
func NewShareBorrowRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares/%s/borrow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShareKillRequest generates requests for ShareKill
func NewShareKillRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares/%s/kill", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShareCreateReportRequest calls the generic ShareCreateReport builder with application/json body
func NewShareCreateReportRequest(server string, id openapi_types.UUID, body ShareCreateReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareCreateReportRequestWithBody(server, id, "application/json", bodyReader)
}

// NewShareCreateReportRequestWithBody generates requests for ShareCreateReport with any type of body
func NewShareCreateReportRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares/%s/report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShareRestoreRequest calls the generic ShareRestore builder with application/json body
func NewShareRestoreRequest(server string, id openapi_types.UUID, params *ShareRestoreParams, body ShareRestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareRestoreRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewShareRestoreRequestWithBody generates requests for ShareRestore with any type of body
func NewShareRestoreRequestWithBody(server string, id openapi_types.UUID, params *ShareRestoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShareUpsertReviewRequest calls the generic ShareUpsertReview builder with application/json body
func NewShareUpsertReviewRequest(server string, id openapi_types.UUID, body ShareUpsertReviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareUpsertReviewRequestWithBody(server, id, "application/json", bodyReader)
}

// NewShareUpsertReviewRequestWithBody generates requests for ShareUpsertReview with any type of body
func NewShareUpsertReviewRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shares/%s/review", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncListEventsRequest generates requests for SyncListEvents
func NewSyncListEventsRequest(server string, params *SyncListEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sync/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderDirection", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncStoreEventRequest calls the generic SyncStoreEvent builder with application/json body
func NewSyncStoreEventRequest(server string, body SyncStoreEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncStoreEventRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncStoreEventRequestWithBody generates requests for SyncStoreEvent with any type of body
func NewSyncStoreEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sync/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserGetManyRequest generates requests for UserGetMany
func NewUserGetManyRequest(server string, params *UserGetManyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderDirection", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserStoreRequest calls the generic UserStore builder with application/json body
func NewUserStoreRequest(server string, body UserStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewUserStoreRequestWithBody generates requests for UserStore with any type of body
func NewUserStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderGetUserPreferencesRequest generates requests for ReaderGetUserPreferences
func NewReaderGetUserPreferencesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/preferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderPatchUserPreferencesRequest calls the generic ReaderPatchUserPreferences builder with application/json body
func NewReaderPatchUserPreferencesRequest(server string, body ReaderPatchUserPreferencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderPatchUserPreferencesRequestWithBody(server, "application/json", bodyReader)
}

// NewReaderPatchUserPreferencesRequestWithBody generates requests for ReaderPatchUserPreferences with any type of body
func NewReaderPatchUserPreferencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/preferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReaderGetUserReaderStateRequest generates requests for ReaderGetUserReaderState
func NewReaderGetUserReaderStateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/reader-state")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReaderPatchUserReaderStateRequest calls the generic ReaderPatchUserReaderState builder with application/json body
func NewReaderPatchUserReaderStateRequest(server string, body ReaderPatchUserReaderStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReaderPatchUserReaderStateRequestWithBody(server, "application/json", bodyReader)
}

// NewReaderPatchUserReaderStateRequestWithBody generates requests for ReaderPatchUserReaderState with any type of body
func NewReaderPatchUserReaderStateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/reader-state")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserDestroyRequest generates requests for UserDestroy
func NewUserDestroyRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserGetByIdRequest generates requests for UserGetById
func NewUserGetByIdRequest(server string, id openapi_types.UUID, params *UserGetByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateRequest calls the generic UserUpdate builder with application/json body
func NewUserUpdateRequest(server string, id openapi_types.UUID, body UserUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUserUpdateRequestWithBody generates requests for UserUpdate with any type of body
func NewUserUpdateRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserKillRequest generates requests for UserKill
func NewUserKillRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/%s/kill", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserRestoreRequest calls the generic UserRestore builder with application/json body
func NewUserRestoreRequest(server string, id openapi_types.UUID, params *UserRestoreParams, body UserRestoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserRestoreRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUserRestoreRequestWithBody generates requests for UserRestore with any type of body
func NewUserRestoreRequestWithBody(server string, id openapi_types.UUID, params *UserRestoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Preloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preloads", runtime.ParamLocationQuery, *params.Preloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHealthGetHealthRequest generates requests for HealthGetHealth
func NewHealthGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ReaderAnnotationsGetManyWithResponse request
	ReaderAnnotationsGetManyWithResponse(ctx context.Context, params *ReaderAnnotationsGetManyParams, reqEditors ...RequestEditorFn) (*ReaderAnnotationsGetManyResponse, error)

	// ReaderAnnotationsStoreWithBodyWithResponse request with any body
	ReaderAnnotationsStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderAnnotationsStoreResponse, error)

	ReaderAnnotationsStoreWithResponse(ctx context.Context, body ReaderAnnotationsStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderAnnotationsStoreResponse, error)

	// ReaderAnnotationsDestroyWithResponse request
	ReaderAnnotationsDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderAnnotationsDestroyResponse, error)

	// ReaderAnnotationsGetByIdWithResponse request
	ReaderAnnotationsGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsGetByIdParams, reqEditors ...RequestEditorFn) (*ReaderAnnotationsGetByIdResponse, error)

	// ReaderAnnotationsUpdateWithBodyWithResponse request with any body
	ReaderAnnotationsUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderAnnotationsUpdateResponse, error)

	ReaderAnnotationsUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body ReaderAnnotationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderAnnotationsUpdateResponse, error)

	// ReaderAnnotationsKillWithResponse request
	ReaderAnnotationsKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderAnnotationsKillResponse, error)

	// ReaderAnnotationsRestoreWithBodyWithResponse request with any body
	ReaderAnnotationsRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderAnnotationsRestoreResponse, error)

	ReaderAnnotationsRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, body ReaderAnnotationsRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderAnnotationsRestoreResponse, error)

	// AuthGoogleLoginWithResponse request
	AuthGoogleLoginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthGoogleLoginResponse, error)

	// AuthGoogleCallbackWithResponse request
	AuthGoogleCallbackWithResponse(ctx context.Context, params *AuthGoogleCallbackParams, reqEditors ...RequestEditorFn) (*AuthGoogleCallbackResponse, error)

	// AuthGoogleDevicePollWithBodyWithResponse request with any body
	AuthGoogleDevicePollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthGoogleDevicePollResponse, error)

	AuthGoogleDevicePollWithResponse(ctx context.Context, body AuthGoogleDevicePollJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthGoogleDevicePollResponse, error)

	// AuthGoogleDeviceStartWithBodyWithResponse request with any body
	AuthGoogleDeviceStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthGoogleDeviceStartResponse, error)

	AuthGoogleDeviceStartWithResponse(ctx context.Context, body AuthGoogleDeviceStartJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthGoogleDeviceStartResponse, error)

	// AuthLoginWithBodyWithResponse request with any body
	AuthLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error)

	AuthLoginWithResponse(ctx context.Context, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error)

	// AuthLogoutWithBodyWithResponse request with any body
	AuthLogoutWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLogoutResponse, error)

	AuthLogoutWithResponse(ctx context.Context, body AuthLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLogoutResponse, error)

	// AuthLogoutAllWithBodyWithResponse request with any body
	AuthLogoutAllWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLogoutAllResponse, error)

	AuthLogoutAllWithResponse(ctx context.Context, body AuthLogoutAllJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLogoutAllResponse, error)

	// AuthMeWithResponse request
	AuthMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthMeResponse, error)

	// AuthRefreshWithBodyWithResponse request with any body
	AuthRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRefreshResponse, error)

	AuthRefreshWithResponse(ctx context.Context, body AuthRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRefreshResponse, error)

	// AuthRegisterWithBodyWithResponse request with any body
	AuthRegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error)

	AuthRegisterWithResponse(ctx context.Context, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error)

	// AuthResendVerificationWithBodyWithResponse request with any body
	AuthResendVerificationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthResendVerificationResponse, error)

	AuthResendVerificationWithResponse(ctx context.Context, body AuthResendVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthResendVerificationResponse, error)

	// AuthVerifyEmailWithBodyWithResponse request with any body
	AuthVerifyEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error)

	AuthVerifyEmailWithResponse(ctx context.Context, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error)

	// ReaderBookmarksGetManyWithResponse request
	ReaderBookmarksGetManyWithResponse(ctx context.Context, params *ReaderBookmarksGetManyParams, reqEditors ...RequestEditorFn) (*ReaderBookmarksGetManyResponse, error)

	// ReaderBookmarksStoreWithBodyWithResponse request with any body
	ReaderBookmarksStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderBookmarksStoreResponse, error)

	ReaderBookmarksStoreWithResponse(ctx context.Context, body ReaderBookmarksStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderBookmarksStoreResponse, error)

	// ReaderBookmarksDestroyWithResponse request
	ReaderBookmarksDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderBookmarksDestroyResponse, error)

	// ReaderBookmarksGetByIdWithResponse request
	ReaderBookmarksGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksGetByIdParams, reqEditors ...RequestEditorFn) (*ReaderBookmarksGetByIdResponse, error)

	// ReaderBookmarksUpdateWithBodyWithResponse request with any body
	ReaderBookmarksUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderBookmarksUpdateResponse, error)

	ReaderBookmarksUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body ReaderBookmarksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderBookmarksUpdateResponse, error)

	// ReaderBookmarksKillWithResponse request
	ReaderBookmarksKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderBookmarksKillResponse, error)

	// ReaderBookmarksRestoreWithBodyWithResponse request with any body
	ReaderBookmarksRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderBookmarksRestoreResponse, error)

	ReaderBookmarksRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, body ReaderBookmarksRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderBookmarksRestoreResponse, error)

	// ShareReturnBorrowWithBodyWithResponse request with any body
	ShareReturnBorrowWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareReturnBorrowResponse, error)

	ShareReturnBorrowWithResponse(ctx context.Context, id openapi_types.UUID, body ShareReturnBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareReturnBorrowResponse, error)

	// EbookGetManyWithResponse request
	EbookGetManyWithResponse(ctx context.Context, params *EbookGetManyParams, reqEditors ...RequestEditorFn) (*EbookGetManyResponse, error)

	// EbookStoreWithBodyWithResponse request with any body
	EbookStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EbookStoreResponse, error)

	EbookStoreWithResponse(ctx context.Context, body EbookStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EbookStoreResponse, error)

	// EbookDestroyWithResponse request
	EbookDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*EbookDestroyResponse, error)

	// EbookGetByIdWithResponse request
	EbookGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *EbookGetByIdParams, reqEditors ...RequestEditorFn) (*EbookGetByIdResponse, error)

	// EbookUpdateWithBodyWithResponse request with any body
	EbookUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EbookUpdateResponse, error)

	EbookUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body EbookUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EbookUpdateResponse, error)

	// EbookKillWithResponse request
	EbookKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*EbookKillResponse, error)

	// EbookRemoveMetadataWithResponse request
	EbookRemoveMetadataWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*EbookRemoveMetadataResponse, error)

	// EbookAttachMetadataWithBodyWithResponse request with any body
	EbookAttachMetadataWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EbookAttachMetadataResponse, error)

	EbookAttachMetadataWithResponse(ctx context.Context, id openapi_types.UUID, body EbookAttachMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*EbookAttachMetadataResponse, error)

	// EbookRestoreWithBodyWithResponse request with any body
	EbookRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *EbookRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EbookRestoreResponse, error)

	EbookRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *EbookRestoreParams, body EbookRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EbookRestoreResponse, error)

	// ReaderReadingProgressGetManyWithResponse request
	ReaderReadingProgressGetManyWithResponse(ctx context.Context, params *ReaderReadingProgressGetManyParams, reqEditors ...RequestEditorFn) (*ReaderReadingProgressGetManyResponse, error)

	// ReaderReadingProgressStoreWithBodyWithResponse request with any body
	ReaderReadingProgressStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderReadingProgressStoreResponse, error)

	ReaderReadingProgressStoreWithResponse(ctx context.Context, body ReaderReadingProgressStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderReadingProgressStoreResponse, error)

	// ReaderReadingProgressDestroyWithResponse request
	ReaderReadingProgressDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderReadingProgressDestroyResponse, error)

	// ReaderReadingProgressGetByIdWithResponse request
	ReaderReadingProgressGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressGetByIdParams, reqEditors ...RequestEditorFn) (*ReaderReadingProgressGetByIdResponse, error)

	// ReaderReadingProgressUpdateWithBodyWithResponse request with any body
	ReaderReadingProgressUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderReadingProgressUpdateResponse, error)

	ReaderReadingProgressUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body ReaderReadingProgressUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderReadingProgressUpdateResponse, error)

	// ReaderReadingProgressKillWithResponse request
	ReaderReadingProgressKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderReadingProgressKillResponse, error)

	// ReaderReadingProgressRestoreWithBodyWithResponse request with any body
	ReaderReadingProgressRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderReadingProgressRestoreResponse, error)

	ReaderReadingProgressRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, body ReaderReadingProgressRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderReadingProgressRestoreResponse, error)

	// ShareGetManyWithResponse request
	ShareGetManyWithResponse(ctx context.Context, params *ShareGetManyParams, reqEditors ...RequestEditorFn) (*ShareGetManyResponse, error)

	// ShareStoreWithBodyWithResponse request with any body
	ShareStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareStoreResponse, error)

	ShareStoreWithResponse(ctx context.Context, body ShareStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareStoreResponse, error)

	// ShareDestroyWithResponse request
	ShareDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ShareDestroyResponse, error)

	// ShareGetByIdWithResponse request
	ShareGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *ShareGetByIdParams, reqEditors ...RequestEditorFn) (*ShareGetByIdResponse, error)

	// ShareUpdateWithBodyWithResponse request with any body
	ShareUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareUpdateResponse, error)

	ShareUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body ShareUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareUpdateResponse, error)

	// ShareBorrowWithBodyWithResponse request with any body
	ShareBorrowWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareBorrowResponse, error)

	ShareBorrowWithResponse(ctx context.Context, id openapi_types.UUID, body ShareBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareBorrowResponse, error)

	// ShareKillWithResponse request
	ShareKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ShareKillResponse, error)

	// ShareCreateReportWithBodyWithResponse request with any body
	ShareCreateReportWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareCreateReportResponse, error)

	ShareCreateReportWithResponse(ctx context.Context, id openapi_types.UUID, body ShareCreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareCreateReportResponse, error)

	// ShareRestoreWithBodyWithResponse request with any body
	ShareRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ShareRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareRestoreResponse, error)

	ShareRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *ShareRestoreParams, body ShareRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareRestoreResponse, error)

	// ShareUpsertReviewWithBodyWithResponse request with any body
	ShareUpsertReviewWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareUpsertReviewResponse, error)

	ShareUpsertReviewWithResponse(ctx context.Context, id openapi_types.UUID, body ShareUpsertReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareUpsertReviewResponse, error)

	// SyncListEventsWithResponse request
	SyncListEventsWithResponse(ctx context.Context, params *SyncListEventsParams, reqEditors ...RequestEditorFn) (*SyncListEventsResponse, error)

	// SyncStoreEventWithBodyWithResponse request with any body
	SyncStoreEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncStoreEventResponse, error)

	SyncStoreEventWithResponse(ctx context.Context, body SyncStoreEventJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncStoreEventResponse, error)

	// UserGetManyWithResponse request
	UserGetManyWithResponse(ctx context.Context, params *UserGetManyParams, reqEditors ...RequestEditorFn) (*UserGetManyResponse, error)

	// UserStoreWithBodyWithResponse request with any body
	UserStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserStoreResponse, error)

	UserStoreWithResponse(ctx context.Context, body UserStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*UserStoreResponse, error)

	// ReaderGetUserPreferencesWithResponse request
	ReaderGetUserPreferencesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReaderGetUserPreferencesResponse, error)

	// ReaderPatchUserPreferencesWithBodyWithResponse request with any body
	ReaderPatchUserPreferencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderPatchUserPreferencesResponse, error)

	ReaderPatchUserPreferencesWithResponse(ctx context.Context, body ReaderPatchUserPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderPatchUserPreferencesResponse, error)

	// ReaderGetUserReaderStateWithResponse request
	ReaderGetUserReaderStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReaderGetUserReaderStateResponse, error)

	// ReaderPatchUserReaderStateWithBodyWithResponse request with any body
	ReaderPatchUserReaderStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderPatchUserReaderStateResponse, error)

	ReaderPatchUserReaderStateWithResponse(ctx context.Context, body ReaderPatchUserReaderStateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderPatchUserReaderStateResponse, error)

	// UserDestroyWithResponse request
	UserDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*UserDestroyResponse, error)

	// UserGetByIdWithResponse request
	UserGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *UserGetByIdParams, reqEditors ...RequestEditorFn) (*UserGetByIdResponse, error)

	// UserUpdateWithBodyWithResponse request with any body
	UserUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error)

	UserUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error)

	// UserKillWithResponse request
	UserKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*UserKillResponse, error)

	// UserRestoreWithBodyWithResponse request with any body
	UserRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UserRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserRestoreResponse, error)

	UserRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *UserRestoreParams, body UserRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*UserRestoreResponse, error)

	// HealthGetHealthWithResponse request
	HealthGetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthGetHealthResponse, error)
}

type ReaderAnnotationsGetManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			Color         *string            `json:"color,omitempty"`
			CreatedAt     time.Time          `json:"createdAt"`
			DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
			EbookId       openapi_types.UUID `json:"ebookId"`
			HighlightText *string            `json:"highlightText,omitempty"`
			Id            openapi_types.UUID `json:"id"`
			LocationEnd   string             `json:"locationEnd"`
			LocationStart string             `json:"locationStart"`
			Note          *string            `json:"note,omitempty"`
			RowVersion    int                `json:"rowVersion"`
			UpdatedAt     time.Time          `json:"updatedAt"`
			UserId        openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Limit      *float32                          `json:"limit,omitempty"`
		Message    *string                           `json:"message,omitempty"`
		Page       float32                           `json:"page"`
		Status     ReaderAnnotationsGetMany200Status `json:"status"`
		Success    *bool                             `json:"success,omitempty"`
		Total      *float32                          `json:"total,omitempty"`
		TotalPages *float32                          `json:"totalPages,omitempty"`
	}
	JSON401 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsGetMany401Status  `json:"status"`
		Success ReaderAnnotationsGetMany401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsGetMany403Status  `json:"status"`
		Success ReaderAnnotationsGetMany403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsGetMany404Status  `json:"status"`
		Success ReaderAnnotationsGetMany404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsGetMany500Status  `json:"status"`
		Success ReaderAnnotationsGetMany500Success `json:"success"`
	}
}
type ReaderAnnotationsGetMany200Status float32
type ReaderAnnotationsGetMany401Status float32
type ReaderAnnotationsGetMany401Success bool
type ReaderAnnotationsGetMany403Status float32
type ReaderAnnotationsGetMany403Success bool
type ReaderAnnotationsGetMany404Status float32
type ReaderAnnotationsGetMany404Success bool
type ReaderAnnotationsGetMany500Status float32
type ReaderAnnotationsGetMany500Success bool

// Status returns HTTPResponse.Status
func (r ReaderAnnotationsGetManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderAnnotationsGetManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderAnnotationsStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data struct {
			Color         *string            `json:"color,omitempty"`
			CreatedAt     time.Time          `json:"createdAt"`
			DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
			EbookId       openapi_types.UUID `json:"ebookId"`
			HighlightText *string            `json:"highlightText,omitempty"`
			Id            openapi_types.UUID `json:"id"`
			LocationEnd   string             `json:"locationEnd"`
			LocationStart string             `json:"locationStart"`
			Note          *string            `json:"note,omitempty"`
			RowVersion    int                `json:"rowVersion"`
			UpdatedAt     time.Time          `json:"updatedAt"`
			UserId        openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderAnnotationsStore401Status  `json:"status"`
		Success ReaderAnnotationsStore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderAnnotationsStore403Status  `json:"status"`
		Success ReaderAnnotationsStore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderAnnotationsStore404Status  `json:"status"`
		Success ReaderAnnotationsStore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderAnnotationsStore500Status  `json:"status"`
		Success ReaderAnnotationsStore500Success `json:"success"`
	}
}
type ReaderAnnotationsStore401Status float32
type ReaderAnnotationsStore401Success bool
type ReaderAnnotationsStore403Status float32
type ReaderAnnotationsStore403Success bool
type ReaderAnnotationsStore404Status float32
type ReaderAnnotationsStore404Success bool
type ReaderAnnotationsStore500Status float32
type ReaderAnnotationsStore500Success bool

// Status returns HTTPResponse.Status
func (r ReaderAnnotationsStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderAnnotationsStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderAnnotationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsDestroy401Status  `json:"status"`
		Success ReaderAnnotationsDestroy401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsDestroy403Status  `json:"status"`
		Success ReaderAnnotationsDestroy403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsDestroy404Status  `json:"status"`
		Success ReaderAnnotationsDestroy404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsDestroy500Status  `json:"status"`
		Success ReaderAnnotationsDestroy500Success `json:"success"`
	}
}
type ReaderAnnotationsDestroy401Status float32
type ReaderAnnotationsDestroy401Success bool
type ReaderAnnotationsDestroy403Status float32
type ReaderAnnotationsDestroy403Success bool
type ReaderAnnotationsDestroy404Status float32
type ReaderAnnotationsDestroy404Success bool
type ReaderAnnotationsDestroy500Status float32
type ReaderAnnotationsDestroy500Success bool

// Status returns HTTPResponse.Status
func (r ReaderAnnotationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderAnnotationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderAnnotationsGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Color         *string            `json:"color,omitempty"`
			CreatedAt     time.Time          `json:"createdAt"`
			DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
			EbookId       openapi_types.UUID `json:"ebookId"`
			HighlightText *string            `json:"highlightText,omitempty"`
			Id            openapi_types.UUID `json:"id"`
			LocationEnd   string             `json:"locationEnd"`
			LocationStart string             `json:"locationStart"`
			Note          *string            `json:"note,omitempty"`
			RowVersion    int                `json:"rowVersion"`
			UpdatedAt     time.Time          `json:"updatedAt"`
			UserId        openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsGetById401Status  `json:"status"`
		Success ReaderAnnotationsGetById401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsGetById403Status  `json:"status"`
		Success ReaderAnnotationsGetById403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsGetById404Status  `json:"status"`
		Success ReaderAnnotationsGetById404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsGetById500Status  `json:"status"`
		Success ReaderAnnotationsGetById500Success `json:"success"`
	}
}
type ReaderAnnotationsGetById401Status float32
type ReaderAnnotationsGetById401Success bool
type ReaderAnnotationsGetById403Status float32
type ReaderAnnotationsGetById403Success bool
type ReaderAnnotationsGetById404Status float32
type ReaderAnnotationsGetById404Success bool
type ReaderAnnotationsGetById500Status float32
type ReaderAnnotationsGetById500Success bool

// Status returns HTTPResponse.Status
func (r ReaderAnnotationsGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderAnnotationsGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderAnnotationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Color         *string            `json:"color,omitempty"`
			CreatedAt     time.Time          `json:"createdAt"`
			DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
			EbookId       openapi_types.UUID `json:"ebookId"`
			HighlightText *string            `json:"highlightText,omitempty"`
			Id            openapi_types.UUID `json:"id"`
			LocationEnd   string             `json:"locationEnd"`
			LocationStart string             `json:"locationStart"`
			Note          *string            `json:"note,omitempty"`
			RowVersion    int                `json:"rowVersion"`
			UpdatedAt     time.Time          `json:"updatedAt"`
			UserId        openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                           `json:"message,omitempty"`
		Status  ReaderAnnotationsUpdate401Status  `json:"status"`
		Success ReaderAnnotationsUpdate401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                           `json:"message,omitempty"`
		Status  ReaderAnnotationsUpdate403Status  `json:"status"`
		Success ReaderAnnotationsUpdate403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                           `json:"message,omitempty"`
		Status  ReaderAnnotationsUpdate404Status  `json:"status"`
		Success ReaderAnnotationsUpdate404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                           `json:"message,omitempty"`
		Status  ReaderAnnotationsUpdate500Status  `json:"status"`
		Success ReaderAnnotationsUpdate500Success `json:"success"`
	}
}
type ReaderAnnotationsUpdate401Status float32
type ReaderAnnotationsUpdate401Success bool
type ReaderAnnotationsUpdate403Status float32
type ReaderAnnotationsUpdate403Success bool
type ReaderAnnotationsUpdate404Status float32
type ReaderAnnotationsUpdate404Success bool
type ReaderAnnotationsUpdate500Status float32
type ReaderAnnotationsUpdate500Success bool

// Status returns HTTPResponse.Status
func (r ReaderAnnotationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderAnnotationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderAnnotationsKillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  ReaderAnnotationsKill401Status  `json:"status"`
		Success ReaderAnnotationsKill401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  ReaderAnnotationsKill403Status  `json:"status"`
		Success ReaderAnnotationsKill403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  ReaderAnnotationsKill404Status  `json:"status"`
		Success ReaderAnnotationsKill404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  ReaderAnnotationsKill500Status  `json:"status"`
		Success ReaderAnnotationsKill500Success `json:"success"`
	}
}
type ReaderAnnotationsKill401Status float32
type ReaderAnnotationsKill401Success bool
type ReaderAnnotationsKill403Status float32
type ReaderAnnotationsKill403Success bool
type ReaderAnnotationsKill404Status float32
type ReaderAnnotationsKill404Success bool
type ReaderAnnotationsKill500Status float32
type ReaderAnnotationsKill500Success bool

// Status returns HTTPResponse.Status
func (r ReaderAnnotationsKillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderAnnotationsKillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderAnnotationsRestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Color         *string            `json:"color,omitempty"`
			CreatedAt     time.Time          `json:"createdAt"`
			DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
			EbookId       openapi_types.UUID `json:"ebookId"`
			HighlightText *string            `json:"highlightText,omitempty"`
			Id            openapi_types.UUID `json:"id"`
			LocationEnd   string             `json:"locationEnd"`
			LocationStart string             `json:"locationStart"`
			Note          *string            `json:"note,omitempty"`
			RowVersion    int                `json:"rowVersion"`
			UpdatedAt     time.Time          `json:"updatedAt"`
			UserId        openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsRestore401Status  `json:"status"`
		Success ReaderAnnotationsRestore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsRestore403Status  `json:"status"`
		Success ReaderAnnotationsRestore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsRestore404Status  `json:"status"`
		Success ReaderAnnotationsRestore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderAnnotationsRestore500Status  `json:"status"`
		Success ReaderAnnotationsRestore500Success `json:"success"`
	}
}
type ReaderAnnotationsRestore401Status float32
type ReaderAnnotationsRestore401Success bool
type ReaderAnnotationsRestore403Status float32
type ReaderAnnotationsRestore403Success bool
type ReaderAnnotationsRestore404Status float32
type ReaderAnnotationsRestore404Success bool
type ReaderAnnotationsRestore500Status float32
type ReaderAnnotationsRestore500Success bool

// Status returns HTTPResponse.Status
func (r ReaderAnnotationsRestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderAnnotationsRestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthGoogleLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON302      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r AuthGoogleLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthGoogleLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthGoogleCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON302      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r AuthGoogleCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthGoogleCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthGoogleDevicePollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *struct {
			RefreshToken struct {
				ExpiresAt time.Time `json:"expiresAt"`
				Token     string    `json:"token"`
			} `json:"refreshToken"`
			Token struct {
				ExpiresAt time.Time `json:"expiresAt"`
				Token     string    `json:"token"`
			} `json:"token"`
			User struct {
				CreatedAt       time.Time           `json:"createdAt"`
				DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
				Email           openapi_types.Email `json:"email"`
				EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
				GoogleId        *string             `json:"googleId,omitempty"`
				Id              openapi_types.UUID  `json:"id"`
				IsAdmin         *bool               `json:"isAdmin,omitempty"`
				LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
				UpdatedAt       time.Time           `json:"updatedAt"`
				Username        string              `json:"username"`
			} `json:"user"`
		} `json:"result,omitempty"`
		Status AuthGoogleDevicePoll200Status `json:"status"`
	}
	JSON401 *struct {
		Message *string                        `json:"message,omitempty"`
		Status  AuthGoogleDevicePoll401Status  `json:"status"`
		Success AuthGoogleDevicePoll401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                        `json:"message,omitempty"`
		Status  AuthGoogleDevicePoll403Status  `json:"status"`
		Success AuthGoogleDevicePoll403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                        `json:"message,omitempty"`
		Status  AuthGoogleDevicePoll404Status  `json:"status"`
		Success AuthGoogleDevicePoll404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                        `json:"message,omitempty"`
		Status  AuthGoogleDevicePoll500Status  `json:"status"`
		Success AuthGoogleDevicePoll500Success `json:"success"`
	}
}
type AuthGoogleDevicePoll200Status string
type AuthGoogleDevicePoll401Status float32
type AuthGoogleDevicePoll401Success bool
type AuthGoogleDevicePoll403Status float32
type AuthGoogleDevicePoll403Success bool
type AuthGoogleDevicePoll404Status float32
type AuthGoogleDevicePoll404Success bool
type AuthGoogleDevicePoll500Status float32
type AuthGoogleDevicePoll500Success bool

// Status returns HTTPResponse.Status
func (r AuthGoogleDevicePollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthGoogleDevicePollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthGoogleDeviceStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AuthUrl         string    `json:"authUrl"`
		DeviceCode      string    `json:"deviceCode"`
		ExpiresAt       time.Time `json:"expiresAt"`
		IntervalSeconds int       `json:"intervalSeconds"`
	}
	JSON401 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  AuthGoogleDeviceStart401Status  `json:"status"`
		Success AuthGoogleDeviceStart401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  AuthGoogleDeviceStart403Status  `json:"status"`
		Success AuthGoogleDeviceStart403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  AuthGoogleDeviceStart404Status  `json:"status"`
		Success AuthGoogleDeviceStart404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  AuthGoogleDeviceStart500Status  `json:"status"`
		Success AuthGoogleDeviceStart500Success `json:"success"`
	}
}
type AuthGoogleDeviceStart401Status float32
type AuthGoogleDeviceStart401Success bool
type AuthGoogleDeviceStart403Status float32
type AuthGoogleDeviceStart403Success bool
type AuthGoogleDeviceStart404Status float32
type AuthGoogleDeviceStart404Success bool
type AuthGoogleDeviceStart500Status float32
type AuthGoogleDeviceStart500Success bool

// Status returns HTTPResponse.Status
func (r AuthGoogleDeviceStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthGoogleDeviceStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreatedAt       time.Time           `json:"createdAt"`
		DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
		Email           openapi_types.Email `json:"email"`
		EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
		GoogleId        *string             `json:"googleId,omitempty"`
		Id              openapi_types.UUID  `json:"id"`
		IsAdmin         *bool               `json:"isAdmin,omitempty"`
		LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
		UpdatedAt       time.Time           `json:"updatedAt"`
		Username        string              `json:"username"`
	}
	JSON401 *struct {
		Message *string             `json:"message,omitempty"`
		Status  AuthLogin401Status  `json:"status"`
		Success AuthLogin401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string             `json:"message,omitempty"`
		Status  AuthLogin403Status  `json:"status"`
		Success AuthLogin403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string             `json:"message,omitempty"`
		Status  AuthLogin404Status  `json:"status"`
		Success AuthLogin404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string             `json:"message,omitempty"`
		Status  AuthLogin500Status  `json:"status"`
		Success AuthLogin500Success `json:"success"`
	}
}
type AuthLogin401Status float32
type AuthLogin401Success bool
type AuthLogin403Status float32
type AuthLogin403Success bool
type AuthLogin404Status float32
type AuthLogin404Success bool
type AuthLogin500Status float32
type AuthLogin500Success bool

// Status returns HTTPResponse.Status
func (r AuthLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string              `json:"message,omitempty"`
		Status  AuthLogout401Status  `json:"status"`
		Success AuthLogout401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string              `json:"message,omitempty"`
		Status  AuthLogout403Status  `json:"status"`
		Success AuthLogout403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string              `json:"message,omitempty"`
		Status  AuthLogout404Status  `json:"status"`
		Success AuthLogout404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string              `json:"message,omitempty"`
		Status  AuthLogout500Status  `json:"status"`
		Success AuthLogout500Success `json:"success"`
	}
}
type AuthLogout401Status float32
type AuthLogout401Success bool
type AuthLogout403Status float32
type AuthLogout403Success bool
type AuthLogout404Status float32
type AuthLogout404Success bool
type AuthLogout500Status float32
type AuthLogout500Success bool

// Status returns HTTPResponse.Status
func (r AuthLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLogoutAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                 `json:"message,omitempty"`
		Status  AuthLogoutAll401Status  `json:"status"`
		Success AuthLogoutAll401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                 `json:"message,omitempty"`
		Status  AuthLogoutAll403Status  `json:"status"`
		Success AuthLogoutAll403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                 `json:"message,omitempty"`
		Status  AuthLogoutAll404Status  `json:"status"`
		Success AuthLogoutAll404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                 `json:"message,omitempty"`
		Status  AuthLogoutAll500Status  `json:"status"`
		Success AuthLogoutAll500Success `json:"success"`
	}
}
type AuthLogoutAll401Status float32
type AuthLogoutAll401Success bool
type AuthLogoutAll403Status float32
type AuthLogoutAll403Success bool
type AuthLogoutAll404Status float32
type AuthLogoutAll404Success bool
type AuthLogoutAll500Status float32
type AuthLogoutAll500Success bool

// Status returns HTTPResponse.Status
func (r AuthLogoutAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLogoutAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreatedAt       time.Time           `json:"createdAt"`
		DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
		Email           openapi_types.Email `json:"email"`
		EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
		GoogleId        *string             `json:"googleId,omitempty"`
		Id              openapi_types.UUID  `json:"id"`
		IsAdmin         *bool               `json:"isAdmin,omitempty"`
		LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
		UpdatedAt       time.Time           `json:"updatedAt"`
		Username        string              `json:"username"`
	}
	JSON401 *struct {
		Message *string          `json:"message,omitempty"`
		Status  AuthMe401Status  `json:"status"`
		Success AuthMe401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string          `json:"message,omitempty"`
		Status  AuthMe403Status  `json:"status"`
		Success AuthMe403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string          `json:"message,omitempty"`
		Status  AuthMe404Status  `json:"status"`
		Success AuthMe404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string          `json:"message,omitempty"`
		Status  AuthMe500Status  `json:"status"`
		Success AuthMe500Success `json:"success"`
	}
}
type AuthMe401Status float32
type AuthMe401Success bool
type AuthMe403Status float32
type AuthMe403Success bool
type AuthMe404Status float32
type AuthMe404Success bool
type AuthMe500Status float32
type AuthMe500Success bool

// Status returns HTTPResponse.Status
func (r AuthMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreatedAt       time.Time           `json:"createdAt"`
		DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
		Email           openapi_types.Email `json:"email"`
		EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
		GoogleId        *string             `json:"googleId,omitempty"`
		Id              openapi_types.UUID  `json:"id"`
		IsAdmin         *bool               `json:"isAdmin,omitempty"`
		LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
		UpdatedAt       time.Time           `json:"updatedAt"`
		Username        string              `json:"username"`
	}
	JSON401 *struct {
		Message *string               `json:"message,omitempty"`
		Status  AuthRefresh401Status  `json:"status"`
		Success AuthRefresh401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string               `json:"message,omitempty"`
		Status  AuthRefresh403Status  `json:"status"`
		Success AuthRefresh403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string               `json:"message,omitempty"`
		Status  AuthRefresh404Status  `json:"status"`
		Success AuthRefresh404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string               `json:"message,omitempty"`
		Status  AuthRefresh500Status  `json:"status"`
		Success AuthRefresh500Success `json:"success"`
	}
}
type AuthRefresh401Status float32
type AuthRefresh401Success bool
type AuthRefresh403Status float32
type AuthRefresh403Success bool
type AuthRefresh404Status float32
type AuthRefresh404Success bool
type AuthRefresh500Status float32
type AuthRefresh500Success bool

// Status returns HTTPResponse.Status
func (r AuthRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthRegisterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		CreatedAt       time.Time           `json:"createdAt"`
		DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
		Email           openapi_types.Email `json:"email"`
		EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
		GoogleId        *string             `json:"googleId,omitempty"`
		Id              openapi_types.UUID  `json:"id"`
		IsAdmin         *bool               `json:"isAdmin,omitempty"`
		LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
		UpdatedAt       time.Time           `json:"updatedAt"`
		Username        string              `json:"username"`
	}
	JSON401 *struct {
		Message *string                `json:"message,omitempty"`
		Status  AuthRegister401Status  `json:"status"`
		Success AuthRegister401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                `json:"message,omitempty"`
		Status  AuthRegister403Status  `json:"status"`
		Success AuthRegister403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                `json:"message,omitempty"`
		Status  AuthRegister404Status  `json:"status"`
		Success AuthRegister404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                `json:"message,omitempty"`
		Status  AuthRegister500Status  `json:"status"`
		Success AuthRegister500Success `json:"success"`
	}
}
type AuthRegister401Status float32
type AuthRegister401Success bool
type AuthRegister403Status float32
type AuthRegister403Success bool
type AuthRegister404Status float32
type AuthRegister404Success bool
type AuthRegister500Status float32
type AuthRegister500Success bool

// Status returns HTTPResponse.Status
func (r AuthRegisterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthRegisterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthResendVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  AuthResendVerification401Status  `json:"status"`
		Success AuthResendVerification401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  AuthResendVerification403Status  `json:"status"`
		Success AuthResendVerification403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  AuthResendVerification404Status  `json:"status"`
		Success AuthResendVerification404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  AuthResendVerification500Status  `json:"status"`
		Success AuthResendVerification500Success `json:"success"`
	}
}
type AuthResendVerification401Status float32
type AuthResendVerification401Success bool
type AuthResendVerification403Status float32
type AuthResendVerification403Success bool
type AuthResendVerification404Status float32
type AuthResendVerification404Success bool
type AuthResendVerification500Status float32
type AuthResendVerification500Success bool

// Status returns HTTPResponse.Status
func (r AuthResendVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthResendVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthVerifyEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreatedAt       time.Time           `json:"createdAt"`
		DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
		Email           openapi_types.Email `json:"email"`
		EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
		GoogleId        *string             `json:"googleId,omitempty"`
		Id              openapi_types.UUID  `json:"id"`
		IsAdmin         *bool               `json:"isAdmin,omitempty"`
		LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
		UpdatedAt       time.Time           `json:"updatedAt"`
		Username        string              `json:"username"`
	}
	JSON401 *struct {
		Message *string                   `json:"message,omitempty"`
		Status  AuthVerifyEmail401Status  `json:"status"`
		Success AuthVerifyEmail401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                   `json:"message,omitempty"`
		Status  AuthVerifyEmail403Status  `json:"status"`
		Success AuthVerifyEmail403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                   `json:"message,omitempty"`
		Status  AuthVerifyEmail404Status  `json:"status"`
		Success AuthVerifyEmail404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                   `json:"message,omitempty"`
		Status  AuthVerifyEmail500Status  `json:"status"`
		Success AuthVerifyEmail500Success `json:"success"`
	}
}
type AuthVerifyEmail401Status float32
type AuthVerifyEmail401Success bool
type AuthVerifyEmail403Status float32
type AuthVerifyEmail403Success bool
type AuthVerifyEmail404Status float32
type AuthVerifyEmail404Success bool
type AuthVerifyEmail500Status float32
type AuthVerifyEmail500Success bool

// Status returns HTTPResponse.Status
func (r AuthVerifyEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthVerifyEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderBookmarksGetManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			CreatedAt  time.Time          `json:"createdAt"`
			DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
			EbookId    openapi_types.UUID `json:"ebookId"`
			Id         openapi_types.UUID `json:"id"`
			Label      *string            `json:"label,omitempty"`
			Location   string             `json:"location"`
			RowVersion int                `json:"rowVersion"`
			UpdatedAt  time.Time          `json:"updatedAt"`
			UserId     openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Limit      *float32                        `json:"limit,omitempty"`
		Message    *string                         `json:"message,omitempty"`
		Page       float32                         `json:"page"`
		Status     ReaderBookmarksGetMany200Status `json:"status"`
		Success    *bool                           `json:"success,omitempty"`
		Total      *float32                        `json:"total,omitempty"`
		TotalPages *float32                        `json:"totalPages,omitempty"`
	}
	JSON401 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksGetMany401Status  `json:"status"`
		Success ReaderBookmarksGetMany401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksGetMany403Status  `json:"status"`
		Success ReaderBookmarksGetMany403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksGetMany404Status  `json:"status"`
		Success ReaderBookmarksGetMany404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksGetMany500Status  `json:"status"`
		Success ReaderBookmarksGetMany500Success `json:"success"`
	}
}
type ReaderBookmarksGetMany200Status float32
type ReaderBookmarksGetMany401Status float32
type ReaderBookmarksGetMany401Success bool
type ReaderBookmarksGetMany403Status float32
type ReaderBookmarksGetMany403Success bool
type ReaderBookmarksGetMany404Status float32
type ReaderBookmarksGetMany404Success bool
type ReaderBookmarksGetMany500Status float32
type ReaderBookmarksGetMany500Success bool

// Status returns HTTPResponse.Status
func (r ReaderBookmarksGetManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderBookmarksGetManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderBookmarksStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data struct {
			CreatedAt  time.Time          `json:"createdAt"`
			DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
			EbookId    openapi_types.UUID `json:"ebookId"`
			Id         openapi_types.UUID `json:"id"`
			Label      *string            `json:"label,omitempty"`
			Location   string             `json:"location"`
			RowVersion int                `json:"rowVersion"`
			UpdatedAt  time.Time          `json:"updatedAt"`
			UserId     openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                        `json:"message,omitempty"`
		Status  ReaderBookmarksStore401Status  `json:"status"`
		Success ReaderBookmarksStore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                        `json:"message,omitempty"`
		Status  ReaderBookmarksStore403Status  `json:"status"`
		Success ReaderBookmarksStore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                        `json:"message,omitempty"`
		Status  ReaderBookmarksStore404Status  `json:"status"`
		Success ReaderBookmarksStore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                        `json:"message,omitempty"`
		Status  ReaderBookmarksStore500Status  `json:"status"`
		Success ReaderBookmarksStore500Success `json:"success"`
	}
}
type ReaderBookmarksStore401Status float32
type ReaderBookmarksStore401Success bool
type ReaderBookmarksStore403Status float32
type ReaderBookmarksStore403Success bool
type ReaderBookmarksStore404Status float32
type ReaderBookmarksStore404Success bool
type ReaderBookmarksStore500Status float32
type ReaderBookmarksStore500Success bool

// Status returns HTTPResponse.Status
func (r ReaderBookmarksStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderBookmarksStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderBookmarksDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksDestroy401Status  `json:"status"`
		Success ReaderBookmarksDestroy401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksDestroy403Status  `json:"status"`
		Success ReaderBookmarksDestroy403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksDestroy404Status  `json:"status"`
		Success ReaderBookmarksDestroy404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksDestroy500Status  `json:"status"`
		Success ReaderBookmarksDestroy500Success `json:"success"`
	}
}
type ReaderBookmarksDestroy401Status float32
type ReaderBookmarksDestroy401Success bool
type ReaderBookmarksDestroy403Status float32
type ReaderBookmarksDestroy403Success bool
type ReaderBookmarksDestroy404Status float32
type ReaderBookmarksDestroy404Success bool
type ReaderBookmarksDestroy500Status float32
type ReaderBookmarksDestroy500Success bool

// Status returns HTTPResponse.Status
func (r ReaderBookmarksDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderBookmarksDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderBookmarksGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt  time.Time          `json:"createdAt"`
			DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
			EbookId    openapi_types.UUID `json:"ebookId"`
			Id         openapi_types.UUID `json:"id"`
			Label      *string            `json:"label,omitempty"`
			Location   string             `json:"location"`
			RowVersion int                `json:"rowVersion"`
			UpdatedAt  time.Time          `json:"updatedAt"`
			UserId     openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksGetById401Status  `json:"status"`
		Success ReaderBookmarksGetById401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksGetById403Status  `json:"status"`
		Success ReaderBookmarksGetById403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksGetById404Status  `json:"status"`
		Success ReaderBookmarksGetById404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksGetById500Status  `json:"status"`
		Success ReaderBookmarksGetById500Success `json:"success"`
	}
}
type ReaderBookmarksGetById401Status float32
type ReaderBookmarksGetById401Success bool
type ReaderBookmarksGetById403Status float32
type ReaderBookmarksGetById403Success bool
type ReaderBookmarksGetById404Status float32
type ReaderBookmarksGetById404Success bool
type ReaderBookmarksGetById500Status float32
type ReaderBookmarksGetById500Success bool

// Status returns HTTPResponse.Status
func (r ReaderBookmarksGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderBookmarksGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderBookmarksUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt  time.Time          `json:"createdAt"`
			DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
			EbookId    openapi_types.UUID `json:"ebookId"`
			Id         openapi_types.UUID `json:"id"`
			Label      *string            `json:"label,omitempty"`
			Location   string             `json:"location"`
			RowVersion int                `json:"rowVersion"`
			UpdatedAt  time.Time          `json:"updatedAt"`
			UserId     openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  ReaderBookmarksUpdate401Status  `json:"status"`
		Success ReaderBookmarksUpdate401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  ReaderBookmarksUpdate403Status  `json:"status"`
		Success ReaderBookmarksUpdate403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  ReaderBookmarksUpdate404Status  `json:"status"`
		Success ReaderBookmarksUpdate404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                         `json:"message,omitempty"`
		Status  ReaderBookmarksUpdate500Status  `json:"status"`
		Success ReaderBookmarksUpdate500Success `json:"success"`
	}
}
type ReaderBookmarksUpdate401Status float32
type ReaderBookmarksUpdate401Success bool
type ReaderBookmarksUpdate403Status float32
type ReaderBookmarksUpdate403Success bool
type ReaderBookmarksUpdate404Status float32
type ReaderBookmarksUpdate404Success bool
type ReaderBookmarksUpdate500Status float32
type ReaderBookmarksUpdate500Success bool

// Status returns HTTPResponse.Status
func (r ReaderBookmarksUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderBookmarksUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderBookmarksKillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  ReaderBookmarksKill401Status  `json:"status"`
		Success ReaderBookmarksKill401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  ReaderBookmarksKill403Status  `json:"status"`
		Success ReaderBookmarksKill403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  ReaderBookmarksKill404Status  `json:"status"`
		Success ReaderBookmarksKill404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  ReaderBookmarksKill500Status  `json:"status"`
		Success ReaderBookmarksKill500Success `json:"success"`
	}
}
type ReaderBookmarksKill401Status float32
type ReaderBookmarksKill401Success bool
type ReaderBookmarksKill403Status float32
type ReaderBookmarksKill403Success bool
type ReaderBookmarksKill404Status float32
type ReaderBookmarksKill404Success bool
type ReaderBookmarksKill500Status float32
type ReaderBookmarksKill500Success bool

// Status returns HTTPResponse.Status
func (r ReaderBookmarksKillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderBookmarksKillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderBookmarksRestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt  time.Time          `json:"createdAt"`
			DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
			EbookId    openapi_types.UUID `json:"ebookId"`
			Id         openapi_types.UUID `json:"id"`
			Label      *string            `json:"label,omitempty"`
			Location   string             `json:"location"`
			RowVersion int                `json:"rowVersion"`
			UpdatedAt  time.Time          `json:"updatedAt"`
			UserId     openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksRestore401Status  `json:"status"`
		Success ReaderBookmarksRestore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksRestore403Status  `json:"status"`
		Success ReaderBookmarksRestore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksRestore404Status  `json:"status"`
		Success ReaderBookmarksRestore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                          `json:"message,omitempty"`
		Status  ReaderBookmarksRestore500Status  `json:"status"`
		Success ReaderBookmarksRestore500Success `json:"success"`
	}
}
type ReaderBookmarksRestore401Status float32
type ReaderBookmarksRestore401Success bool
type ReaderBookmarksRestore403Status float32
type ReaderBookmarksRestore403Success bool
type ReaderBookmarksRestore404Status float32
type ReaderBookmarksRestore404Success bool
type ReaderBookmarksRestore500Status float32
type ReaderBookmarksRestore500Success bool

// Status returns HTTPResponse.Status
func (r ReaderBookmarksRestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderBookmarksRestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareReturnBorrowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			BorrowerUserId      openapi_types.UUID             `json:"borrowerUserId"`
			CreatedAt           time.Time                      `json:"createdAt"`
			DueAt               time.Time                      `json:"dueAt"`
			ExpiredAt           *time.Time                     `json:"expiredAt,omitempty"`
			Id                  openapi_types.UUID             `json:"id"`
			LegalAcknowledgedAt time.Time                      `json:"legalAcknowledgedAt"`
			ReturnedAt          *time.Time                     `json:"returnedAt,omitempty"`
			ShareId             openapi_types.UUID             `json:"shareId"`
			StartedAt           time.Time                      `json:"startedAt"`
			Status              ShareReturnBorrow200DataStatus `json:"status"`
			UpdatedAt           time.Time                      `json:"updatedAt"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareReturnBorrow401Status  `json:"status"`
		Success ShareReturnBorrow401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareReturnBorrow403Status  `json:"status"`
		Success ShareReturnBorrow403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareReturnBorrow404Status  `json:"status"`
		Success ShareReturnBorrow404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareReturnBorrow500Status  `json:"status"`
		Success ShareReturnBorrow500Success `json:"success"`
	}
}
type ShareReturnBorrow200DataStatus string
type ShareReturnBorrow401Status float32
type ShareReturnBorrow401Success bool
type ShareReturnBorrow403Status float32
type ShareReturnBorrow403Success bool
type ShareReturnBorrow404Status float32
type ShareReturnBorrow404Success bool
type ShareReturnBorrow500Status float32
type ShareReturnBorrow500Success bool

// Status returns HTTPResponse.Status
func (r ShareReturnBorrowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareReturnBorrowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EbookGetManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			ChecksumSha256 string                    `json:"checksumSha256"`
			CreatedAt      time.Time                 `json:"createdAt"`
			DeletedAt      *time.Time                `json:"deletedAt,omitempty"`
			Description    *string                   `json:"description,omitempty"`
			FileSizeBytes  int                       `json:"fileSizeBytes"`
			Format         EbookGetMany200DataFormat `json:"format"`
			Id             openapi_types.UUID        `json:"id"`
			ImportedAt     time.Time                 `json:"importedAt"`
			LanguageCode   *string                   `json:"languageCode,omitempty"`
			OwnerUserId    openapi_types.UUID        `json:"ownerUserId"`
			StorageKey     string                    `json:"storageKey"`
			Title          string                    `json:"title"`
			UpdatedAt      time.Time                 `json:"updatedAt"`
		} `json:"data"`
		Limit      *float32              `json:"limit,omitempty"`
		Message    *string               `json:"message,omitempty"`
		Page       float32               `json:"page"`
		Status     EbookGetMany200Status `json:"status"`
		Success    *bool                 `json:"success,omitempty"`
		Total      *float32              `json:"total,omitempty"`
		TotalPages *float32              `json:"totalPages,omitempty"`
	}
	JSON401 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookGetMany401Status  `json:"status"`
		Success EbookGetMany401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookGetMany403Status  `json:"status"`
		Success EbookGetMany403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookGetMany404Status  `json:"status"`
		Success EbookGetMany404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookGetMany500Status  `json:"status"`
		Success EbookGetMany500Success `json:"success"`
	}
}
type EbookGetMany200DataFormat string
type EbookGetMany200Status float32
type EbookGetMany401Status float32
type EbookGetMany401Success bool
type EbookGetMany403Status float32
type EbookGetMany403Success bool
type EbookGetMany404Status float32
type EbookGetMany404Success bool
type EbookGetMany500Status float32
type EbookGetMany500Success bool

// Status returns HTTPResponse.Status
func (r EbookGetManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EbookGetManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EbookStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data struct {
			ChecksumSha256 string                  `json:"checksumSha256"`
			CreatedAt      time.Time               `json:"createdAt"`
			DeletedAt      *time.Time              `json:"deletedAt,omitempty"`
			Description    *string                 `json:"description,omitempty"`
			FileSizeBytes  int                     `json:"fileSizeBytes"`
			Format         EbookStore201DataFormat `json:"format"`
			Id             openapi_types.UUID      `json:"id"`
			ImportedAt     time.Time               `json:"importedAt"`
			LanguageCode   *string                 `json:"languageCode,omitempty"`
			OwnerUserId    openapi_types.UUID      `json:"ownerUserId"`
			StorageKey     string                  `json:"storageKey"`
			Title          string                  `json:"title"`
			UpdatedAt      time.Time               `json:"updatedAt"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string              `json:"message,omitempty"`
		Status  EbookStore401Status  `json:"status"`
		Success EbookStore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string              `json:"message,omitempty"`
		Status  EbookStore403Status  `json:"status"`
		Success EbookStore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string              `json:"message,omitempty"`
		Status  EbookStore404Status  `json:"status"`
		Success EbookStore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string              `json:"message,omitempty"`
		Status  EbookStore500Status  `json:"status"`
		Success EbookStore500Success `json:"success"`
	}
}
type EbookStore201DataFormat string
type EbookStore401Status float32
type EbookStore401Success bool
type EbookStore403Status float32
type EbookStore403Success bool
type EbookStore404Status float32
type EbookStore404Success bool
type EbookStore500Status float32
type EbookStore500Success bool

// Status returns HTTPResponse.Status
func (r EbookStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EbookStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EbookDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookDestroy401Status  `json:"status"`
		Success EbookDestroy401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookDestroy403Status  `json:"status"`
		Success EbookDestroy403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookDestroy404Status  `json:"status"`
		Success EbookDestroy404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookDestroy500Status  `json:"status"`
		Success EbookDestroy500Success `json:"success"`
	}
}
type EbookDestroy401Status float32
type EbookDestroy401Success bool
type EbookDestroy403Status float32
type EbookDestroy403Success bool
type EbookDestroy404Status float32
type EbookDestroy404Success bool
type EbookDestroy500Status float32
type EbookDestroy500Success bool

// Status returns HTTPResponse.Status
func (r EbookDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EbookDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EbookGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			ChecksumSha256 string                    `json:"checksumSha256"`
			CreatedAt      time.Time                 `json:"createdAt"`
			DeletedAt      *time.Time                `json:"deletedAt,omitempty"`
			Description    *string                   `json:"description,omitempty"`
			FileSizeBytes  int                       `json:"fileSizeBytes"`
			Format         EbookGetById200DataFormat `json:"format"`
			Id             openapi_types.UUID        `json:"id"`
			ImportedAt     time.Time                 `json:"importedAt"`
			LanguageCode   *string                   `json:"languageCode,omitempty"`
			OwnerUserId    openapi_types.UUID        `json:"ownerUserId"`
			StorageKey     string                    `json:"storageKey"`
			Title          string                    `json:"title"`
			UpdatedAt      time.Time                 `json:"updatedAt"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookGetById401Status  `json:"status"`
		Success EbookGetById401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookGetById403Status  `json:"status"`
		Success EbookGetById403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookGetById404Status  `json:"status"`
		Success EbookGetById404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookGetById500Status  `json:"status"`
		Success EbookGetById500Success `json:"success"`
	}
}
type EbookGetById200DataFormat string
type EbookGetById401Status float32
type EbookGetById401Success bool
type EbookGetById403Status float32
type EbookGetById403Success bool
type EbookGetById404Status float32
type EbookGetById404Success bool
type EbookGetById500Status float32
type EbookGetById500Success bool

// Status returns HTTPResponse.Status
func (r EbookGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EbookGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EbookUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			ChecksumSha256 string                   `json:"checksumSha256"`
			CreatedAt      time.Time                `json:"createdAt"`
			DeletedAt      *time.Time               `json:"deletedAt,omitempty"`
			Description    *string                  `json:"description,omitempty"`
			FileSizeBytes  int                      `json:"fileSizeBytes"`
			Format         EbookUpdate200DataFormat `json:"format"`
			Id             openapi_types.UUID       `json:"id"`
			ImportedAt     time.Time                `json:"importedAt"`
			LanguageCode   *string                  `json:"languageCode,omitempty"`
			OwnerUserId    openapi_types.UUID       `json:"ownerUserId"`
			StorageKey     string                   `json:"storageKey"`
			Title          string                   `json:"title"`
			UpdatedAt      time.Time                `json:"updatedAt"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string               `json:"message,omitempty"`
		Status  EbookUpdate401Status  `json:"status"`
		Success EbookUpdate401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string               `json:"message,omitempty"`
		Status  EbookUpdate403Status  `json:"status"`
		Success EbookUpdate403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string               `json:"message,omitempty"`
		Status  EbookUpdate404Status  `json:"status"`
		Success EbookUpdate404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string               `json:"message,omitempty"`
		Status  EbookUpdate500Status  `json:"status"`
		Success EbookUpdate500Success `json:"success"`
	}
}
type EbookUpdate200DataFormat string
type EbookUpdate401Status float32
type EbookUpdate401Success bool
type EbookUpdate403Status float32
type EbookUpdate403Success bool
type EbookUpdate404Status float32
type EbookUpdate404Success bool
type EbookUpdate500Status float32
type EbookUpdate500Success bool

// Status returns HTTPResponse.Status
func (r EbookUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EbookUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EbookKillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string             `json:"message,omitempty"`
		Status  EbookKill401Status  `json:"status"`
		Success EbookKill401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string             `json:"message,omitempty"`
		Status  EbookKill403Status  `json:"status"`
		Success EbookKill403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string             `json:"message,omitempty"`
		Status  EbookKill404Status  `json:"status"`
		Success EbookKill404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string             `json:"message,omitempty"`
		Status  EbookKill500Status  `json:"status"`
		Success EbookKill500Success `json:"success"`
	}
}
type EbookKill401Status float32
type EbookKill401Success bool
type EbookKill403Status float32
type EbookKill403Success bool
type EbookKill404Status float32
type EbookKill404Success bool
type EbookKill500Status float32
type EbookKill500Success bool

// Status returns HTTPResponse.Status
func (r EbookKillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EbookKillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EbookRemoveMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  EbookRemoveMetadata401Status  `json:"status"`
		Success EbookRemoveMetadata401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  EbookRemoveMetadata403Status  `json:"status"`
		Success EbookRemoveMetadata403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  EbookRemoveMetadata404Status  `json:"status"`
		Success EbookRemoveMetadata404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  EbookRemoveMetadata500Status  `json:"status"`
		Success EbookRemoveMetadata500Success `json:"success"`
	}
}
type EbookRemoveMetadata401Status float32
type EbookRemoveMetadata401Success bool
type EbookRemoveMetadata403Status float32
type EbookRemoveMetadata403Success bool
type EbookRemoveMetadata404Status float32
type EbookRemoveMetadata404Success bool
type EbookRemoveMetadata500Status float32
type EbookRemoveMetadata500Success bool

// Status returns HTTPResponse.Status
func (r EbookRemoveMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EbookRemoveMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EbookAttachMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			AttachedAt    time.Time                `json:"attachedAt"`
			Categories    *[]string                `json:"categories,omitempty"`
			DeletedAt     *time.Time               `json:"deletedAt,omitempty"`
			EbookId       openapi_types.UUID       `json:"ebookId"`
			GoogleBooksId string                   `json:"googleBooksId"`
			InfoLink      *string                  `json:"infoLink,omitempty"`
			Isbn10        *string                  `json:"isbn10,omitempty"`
			Isbn13        *string                  `json:"isbn13,omitempty"`
			PageCount     *int                     `json:"pageCount,omitempty"`
			PublishedDate *string                  `json:"publishedDate,omitempty"`
			Publisher     *string                  `json:"publisher,omitempty"`
			RawPayload    *map[string]*interface{} `json:"rawPayload,omitempty"`
			ThumbnailUrl  *string                  `json:"thumbnailUrl,omitempty"`
			UpdatedAt     time.Time                `json:"updatedAt"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  EbookAttachMetadata401Status  `json:"status"`
		Success EbookAttachMetadata401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  EbookAttachMetadata403Status  `json:"status"`
		Success EbookAttachMetadata403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  EbookAttachMetadata404Status  `json:"status"`
		Success EbookAttachMetadata404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                       `json:"message,omitempty"`
		Status  EbookAttachMetadata500Status  `json:"status"`
		Success EbookAttachMetadata500Success `json:"success"`
	}
}
type EbookAttachMetadata401Status float32
type EbookAttachMetadata401Success bool
type EbookAttachMetadata403Status float32
type EbookAttachMetadata403Success bool
type EbookAttachMetadata404Status float32
type EbookAttachMetadata404Success bool
type EbookAttachMetadata500Status float32
type EbookAttachMetadata500Success bool

// Status returns HTTPResponse.Status
func (r EbookAttachMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EbookAttachMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EbookRestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			ChecksumSha256 string                    `json:"checksumSha256"`
			CreatedAt      time.Time                 `json:"createdAt"`
			DeletedAt      *time.Time                `json:"deletedAt,omitempty"`
			Description    *string                   `json:"description,omitempty"`
			FileSizeBytes  int                       `json:"fileSizeBytes"`
			Format         EbookRestore200DataFormat `json:"format"`
			Id             openapi_types.UUID        `json:"id"`
			ImportedAt     time.Time                 `json:"importedAt"`
			LanguageCode   *string                   `json:"languageCode,omitempty"`
			OwnerUserId    openapi_types.UUID        `json:"ownerUserId"`
			StorageKey     string                    `json:"storageKey"`
			Title          string                    `json:"title"`
			UpdatedAt      time.Time                 `json:"updatedAt"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookRestore401Status  `json:"status"`
		Success EbookRestore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookRestore403Status  `json:"status"`
		Success EbookRestore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookRestore404Status  `json:"status"`
		Success EbookRestore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                `json:"message,omitempty"`
		Status  EbookRestore500Status  `json:"status"`
		Success EbookRestore500Success `json:"success"`
	}
}
type EbookRestore200DataFormat string
type EbookRestore401Status float32
type EbookRestore401Success bool
type EbookRestore403Status float32
type EbookRestore403Success bool
type EbookRestore404Status float32
type EbookRestore404Success bool
type EbookRestore500Status float32
type EbookRestore500Success bool

// Status returns HTTPResponse.Status
func (r EbookRestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EbookRestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderReadingProgressGetManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			CreatedAt       time.Time                                      `json:"createdAt"`
			DeletedAt       *time.Time                                     `json:"deletedAt,omitempty"`
			EbookId         openapi_types.UUID                             `json:"ebookId"`
			Id              openapi_types.UUID                             `json:"id"`
			LastReadAt      *time.Time                                     `json:"lastReadAt,omitempty"`
			Location        string                                         `json:"location"`
			ProgressPercent *float32                                       `json:"progressPercent,omitempty"`
			ReadingMode     ReaderReadingProgressGetMany200DataReadingMode `json:"readingMode"`
			RowVersion      int                                            `json:"rowVersion"`
			UpdatedAt       time.Time                                      `json:"updatedAt"`
			UserId          openapi_types.UUID                             `json:"userId"`
		} `json:"data"`
		Limit      *float32                              `json:"limit,omitempty"`
		Message    *string                               `json:"message,omitempty"`
		Page       float32                               `json:"page"`
		Status     ReaderReadingProgressGetMany200Status `json:"status"`
		Success    *bool                                 `json:"success,omitempty"`
		Total      *float32                              `json:"total,omitempty"`
		TotalPages *float32                              `json:"totalPages,omitempty"`
	}
	JSON401 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressGetMany401Status  `json:"status"`
		Success ReaderReadingProgressGetMany401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressGetMany403Status  `json:"status"`
		Success ReaderReadingProgressGetMany403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressGetMany404Status  `json:"status"`
		Success ReaderReadingProgressGetMany404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressGetMany500Status  `json:"status"`
		Success ReaderReadingProgressGetMany500Success `json:"success"`
	}
}
type ReaderReadingProgressGetMany200DataReadingMode string
type ReaderReadingProgressGetMany200Status float32
type ReaderReadingProgressGetMany401Status float32
type ReaderReadingProgressGetMany401Success bool
type ReaderReadingProgressGetMany403Status float32
type ReaderReadingProgressGetMany403Success bool
type ReaderReadingProgressGetMany404Status float32
type ReaderReadingProgressGetMany404Success bool
type ReaderReadingProgressGetMany500Status float32
type ReaderReadingProgressGetMany500Success bool

// Status returns HTTPResponse.Status
func (r ReaderReadingProgressGetManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderReadingProgressGetManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderReadingProgressStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data struct {
			CreatedAt       time.Time                                    `json:"createdAt"`
			DeletedAt       *time.Time                                   `json:"deletedAt,omitempty"`
			EbookId         openapi_types.UUID                           `json:"ebookId"`
			Id              openapi_types.UUID                           `json:"id"`
			LastReadAt      *time.Time                                   `json:"lastReadAt,omitempty"`
			Location        string                                       `json:"location"`
			ProgressPercent *float32                                     `json:"progressPercent,omitempty"`
			ReadingMode     ReaderReadingProgressStore201DataReadingMode `json:"readingMode"`
			RowVersion      int                                          `json:"rowVersion"`
			UpdatedAt       time.Time                                    `json:"updatedAt"`
			UserId          openapi_types.UUID                           `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderReadingProgressStore401Status  `json:"status"`
		Success ReaderReadingProgressStore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderReadingProgressStore403Status  `json:"status"`
		Success ReaderReadingProgressStore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderReadingProgressStore404Status  `json:"status"`
		Success ReaderReadingProgressStore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderReadingProgressStore500Status  `json:"status"`
		Success ReaderReadingProgressStore500Success `json:"success"`
	}
}
type ReaderReadingProgressStore201DataReadingMode string
type ReaderReadingProgressStore401Status float32
type ReaderReadingProgressStore401Success bool
type ReaderReadingProgressStore403Status float32
type ReaderReadingProgressStore403Success bool
type ReaderReadingProgressStore404Status float32
type ReaderReadingProgressStore404Success bool
type ReaderReadingProgressStore500Status float32
type ReaderReadingProgressStore500Success bool

// Status returns HTTPResponse.Status
func (r ReaderReadingProgressStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderReadingProgressStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderReadingProgressDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressDestroy401Status  `json:"status"`
		Success ReaderReadingProgressDestroy401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressDestroy403Status  `json:"status"`
		Success ReaderReadingProgressDestroy403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressDestroy404Status  `json:"status"`
		Success ReaderReadingProgressDestroy404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressDestroy500Status  `json:"status"`
		Success ReaderReadingProgressDestroy500Success `json:"success"`
	}
}
type ReaderReadingProgressDestroy401Status float32
type ReaderReadingProgressDestroy401Success bool
type ReaderReadingProgressDestroy403Status float32
type ReaderReadingProgressDestroy403Success bool
type ReaderReadingProgressDestroy404Status float32
type ReaderReadingProgressDestroy404Success bool
type ReaderReadingProgressDestroy500Status float32
type ReaderReadingProgressDestroy500Success bool

// Status returns HTTPResponse.Status
func (r ReaderReadingProgressDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderReadingProgressDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderReadingProgressGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt       time.Time                                      `json:"createdAt"`
			DeletedAt       *time.Time                                     `json:"deletedAt,omitempty"`
			EbookId         openapi_types.UUID                             `json:"ebookId"`
			Id              openapi_types.UUID                             `json:"id"`
			LastReadAt      *time.Time                                     `json:"lastReadAt,omitempty"`
			Location        string                                         `json:"location"`
			ProgressPercent *float32                                       `json:"progressPercent,omitempty"`
			ReadingMode     ReaderReadingProgressGetById200DataReadingMode `json:"readingMode"`
			RowVersion      int                                            `json:"rowVersion"`
			UpdatedAt       time.Time                                      `json:"updatedAt"`
			UserId          openapi_types.UUID                             `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressGetById401Status  `json:"status"`
		Success ReaderReadingProgressGetById401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressGetById403Status  `json:"status"`
		Success ReaderReadingProgressGetById403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressGetById404Status  `json:"status"`
		Success ReaderReadingProgressGetById404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressGetById500Status  `json:"status"`
		Success ReaderReadingProgressGetById500Success `json:"success"`
	}
}
type ReaderReadingProgressGetById200DataReadingMode string
type ReaderReadingProgressGetById401Status float32
type ReaderReadingProgressGetById401Success bool
type ReaderReadingProgressGetById403Status float32
type ReaderReadingProgressGetById403Success bool
type ReaderReadingProgressGetById404Status float32
type ReaderReadingProgressGetById404Success bool
type ReaderReadingProgressGetById500Status float32
type ReaderReadingProgressGetById500Success bool

// Status returns HTTPResponse.Status
func (r ReaderReadingProgressGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderReadingProgressGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderReadingProgressUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt       time.Time                                     `json:"createdAt"`
			DeletedAt       *time.Time                                    `json:"deletedAt,omitempty"`
			EbookId         openapi_types.UUID                            `json:"ebookId"`
			Id              openapi_types.UUID                            `json:"id"`
			LastReadAt      *time.Time                                    `json:"lastReadAt,omitempty"`
			Location        string                                        `json:"location"`
			ProgressPercent *float32                                      `json:"progressPercent,omitempty"`
			ReadingMode     ReaderReadingProgressUpdate200DataReadingMode `json:"readingMode"`
			RowVersion      int                                           `json:"rowVersion"`
			UpdatedAt       time.Time                                     `json:"updatedAt"`
			UserId          openapi_types.UUID                            `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                               `json:"message,omitempty"`
		Status  ReaderReadingProgressUpdate401Status  `json:"status"`
		Success ReaderReadingProgressUpdate401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                               `json:"message,omitempty"`
		Status  ReaderReadingProgressUpdate403Status  `json:"status"`
		Success ReaderReadingProgressUpdate403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                               `json:"message,omitempty"`
		Status  ReaderReadingProgressUpdate404Status  `json:"status"`
		Success ReaderReadingProgressUpdate404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                               `json:"message,omitempty"`
		Status  ReaderReadingProgressUpdate500Status  `json:"status"`
		Success ReaderReadingProgressUpdate500Success `json:"success"`
	}
}
type ReaderReadingProgressUpdate200DataReadingMode string
type ReaderReadingProgressUpdate401Status float32
type ReaderReadingProgressUpdate401Success bool
type ReaderReadingProgressUpdate403Status float32
type ReaderReadingProgressUpdate403Success bool
type ReaderReadingProgressUpdate404Status float32
type ReaderReadingProgressUpdate404Success bool
type ReaderReadingProgressUpdate500Status float32
type ReaderReadingProgressUpdate500Success bool

// Status returns HTTPResponse.Status
func (r ReaderReadingProgressUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderReadingProgressUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderReadingProgressKillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                             `json:"message,omitempty"`
		Status  ReaderReadingProgressKill401Status  `json:"status"`
		Success ReaderReadingProgressKill401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                             `json:"message,omitempty"`
		Status  ReaderReadingProgressKill403Status  `json:"status"`
		Success ReaderReadingProgressKill403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                             `json:"message,omitempty"`
		Status  ReaderReadingProgressKill404Status  `json:"status"`
		Success ReaderReadingProgressKill404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                             `json:"message,omitempty"`
		Status  ReaderReadingProgressKill500Status  `json:"status"`
		Success ReaderReadingProgressKill500Success `json:"success"`
	}
}
type ReaderReadingProgressKill401Status float32
type ReaderReadingProgressKill401Success bool
type ReaderReadingProgressKill403Status float32
type ReaderReadingProgressKill403Success bool
type ReaderReadingProgressKill404Status float32
type ReaderReadingProgressKill404Success bool
type ReaderReadingProgressKill500Status float32
type ReaderReadingProgressKill500Success bool

// Status returns HTTPResponse.Status
func (r ReaderReadingProgressKillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderReadingProgressKillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderReadingProgressRestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt       time.Time                                      `json:"createdAt"`
			DeletedAt       *time.Time                                     `json:"deletedAt,omitempty"`
			EbookId         openapi_types.UUID                             `json:"ebookId"`
			Id              openapi_types.UUID                             `json:"id"`
			LastReadAt      *time.Time                                     `json:"lastReadAt,omitempty"`
			Location        string                                         `json:"location"`
			ProgressPercent *float32                                       `json:"progressPercent,omitempty"`
			ReadingMode     ReaderReadingProgressRestore200DataReadingMode `json:"readingMode"`
			RowVersion      int                                            `json:"rowVersion"`
			UpdatedAt       time.Time                                      `json:"updatedAt"`
			UserId          openapi_types.UUID                             `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressRestore401Status  `json:"status"`
		Success ReaderReadingProgressRestore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressRestore403Status  `json:"status"`
		Success ReaderReadingProgressRestore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressRestore404Status  `json:"status"`
		Success ReaderReadingProgressRestore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                                `json:"message,omitempty"`
		Status  ReaderReadingProgressRestore500Status  `json:"status"`
		Success ReaderReadingProgressRestore500Success `json:"success"`
	}
}
type ReaderReadingProgressRestore200DataReadingMode string
type ReaderReadingProgressRestore401Status float32
type ReaderReadingProgressRestore401Success bool
type ReaderReadingProgressRestore403Status float32
type ReaderReadingProgressRestore403Success bool
type ReaderReadingProgressRestore404Status float32
type ReaderReadingProgressRestore404Success bool
type ReaderReadingProgressRestore500Status float32
type ReaderReadingProgressRestore500Success bool

// Status returns HTTPResponse.Status
func (r ReaderReadingProgressRestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderReadingProgressRestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareGetManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			BorrowDurationHours  int                           `json:"borrowDurationHours"`
			CreatedAt            time.Time                     `json:"createdAt"`
			DeletedAt            *time.Time                    `json:"deletedAt,omitempty"`
			Description          *string                       `json:"description,omitempty"`
			EbookId              openapi_types.UUID            `json:"ebookId"`
			Id                   openapi_types.UUID            `json:"id"`
			MaxConcurrentBorrows int                           `json:"maxConcurrentBorrows"`
			OwnerUserId          openapi_types.UUID            `json:"ownerUserId"`
			Status               ShareGetMany200DataStatus     `json:"status"`
			TitleOverride        *string                       `json:"titleOverride,omitempty"`
			UpdatedAt            time.Time                     `json:"updatedAt"`
			Visibility           ShareGetMany200DataVisibility `json:"visibility"`
		} `json:"data"`
		Limit      *float32              `json:"limit,omitempty"`
		Message    *string               `json:"message,omitempty"`
		Page       float32               `json:"page"`
		Status     ShareGetMany200Status `json:"status"`
		Success    *bool                 `json:"success,omitempty"`
		Total      *float32              `json:"total,omitempty"`
		TotalPages *float32              `json:"totalPages,omitempty"`
	}
	JSON401 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareGetMany401Status  `json:"status"`
		Success ShareGetMany401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareGetMany403Status  `json:"status"`
		Success ShareGetMany403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareGetMany404Status  `json:"status"`
		Success ShareGetMany404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareGetMany500Status  `json:"status"`
		Success ShareGetMany500Success `json:"success"`
	}
}
type ShareGetMany200DataStatus string
type ShareGetMany200DataVisibility string
type ShareGetMany200Status float32
type ShareGetMany401Status float32
type ShareGetMany401Success bool
type ShareGetMany403Status float32
type ShareGetMany403Success bool
type ShareGetMany404Status float32
type ShareGetMany404Success bool
type ShareGetMany500Status float32
type ShareGetMany500Success bool

// Status returns HTTPResponse.Status
func (r ShareGetManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareGetManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data struct {
			BorrowDurationHours  int                         `json:"borrowDurationHours"`
			CreatedAt            time.Time                   `json:"createdAt"`
			DeletedAt            *time.Time                  `json:"deletedAt,omitempty"`
			Description          *string                     `json:"description,omitempty"`
			EbookId              openapi_types.UUID          `json:"ebookId"`
			Id                   openapi_types.UUID          `json:"id"`
			MaxConcurrentBorrows int                         `json:"maxConcurrentBorrows"`
			OwnerUserId          openapi_types.UUID          `json:"ownerUserId"`
			Status               ShareStore201DataStatus     `json:"status"`
			TitleOverride        *string                     `json:"titleOverride,omitempty"`
			UpdatedAt            time.Time                   `json:"updatedAt"`
			Visibility           ShareStore201DataVisibility `json:"visibility"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string              `json:"message,omitempty"`
		Status  ShareStore401Status  `json:"status"`
		Success ShareStore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string              `json:"message,omitempty"`
		Status  ShareStore403Status  `json:"status"`
		Success ShareStore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string              `json:"message,omitempty"`
		Status  ShareStore404Status  `json:"status"`
		Success ShareStore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string              `json:"message,omitempty"`
		Status  ShareStore500Status  `json:"status"`
		Success ShareStore500Success `json:"success"`
	}
}
type ShareStore201DataStatus string
type ShareStore201DataVisibility string
type ShareStore401Status float32
type ShareStore401Success bool
type ShareStore403Status float32
type ShareStore403Success bool
type ShareStore404Status float32
type ShareStore404Success bool
type ShareStore500Status float32
type ShareStore500Success bool

// Status returns HTTPResponse.Status
func (r ShareStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareDestroy401Status  `json:"status"`
		Success ShareDestroy401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareDestroy403Status  `json:"status"`
		Success ShareDestroy403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareDestroy404Status  `json:"status"`
		Success ShareDestroy404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareDestroy500Status  `json:"status"`
		Success ShareDestroy500Success `json:"success"`
	}
}
type ShareDestroy401Status float32
type ShareDestroy401Success bool
type ShareDestroy403Status float32
type ShareDestroy403Success bool
type ShareDestroy404Status float32
type ShareDestroy404Success bool
type ShareDestroy500Status float32
type ShareDestroy500Success bool

// Status returns HTTPResponse.Status
func (r ShareDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			BorrowDurationHours  int                           `json:"borrowDurationHours"`
			CreatedAt            time.Time                     `json:"createdAt"`
			DeletedAt            *time.Time                    `json:"deletedAt,omitempty"`
			Description          *string                       `json:"description,omitempty"`
			EbookId              openapi_types.UUID            `json:"ebookId"`
			Id                   openapi_types.UUID            `json:"id"`
			MaxConcurrentBorrows int                           `json:"maxConcurrentBorrows"`
			OwnerUserId          openapi_types.UUID            `json:"ownerUserId"`
			Status               ShareGetById200DataStatus     `json:"status"`
			TitleOverride        *string                       `json:"titleOverride,omitempty"`
			UpdatedAt            time.Time                     `json:"updatedAt"`
			Visibility           ShareGetById200DataVisibility `json:"visibility"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareGetById401Status  `json:"status"`
		Success ShareGetById401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareGetById403Status  `json:"status"`
		Success ShareGetById403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareGetById404Status  `json:"status"`
		Success ShareGetById404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareGetById500Status  `json:"status"`
		Success ShareGetById500Success `json:"success"`
	}
}
type ShareGetById200DataStatus string
type ShareGetById200DataVisibility string
type ShareGetById401Status float32
type ShareGetById401Success bool
type ShareGetById403Status float32
type ShareGetById403Success bool
type ShareGetById404Status float32
type ShareGetById404Success bool
type ShareGetById500Status float32
type ShareGetById500Success bool

// Status returns HTTPResponse.Status
func (r ShareGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			BorrowDurationHours  int                          `json:"borrowDurationHours"`
			CreatedAt            time.Time                    `json:"createdAt"`
			DeletedAt            *time.Time                   `json:"deletedAt,omitempty"`
			Description          *string                      `json:"description,omitempty"`
			EbookId              openapi_types.UUID           `json:"ebookId"`
			Id                   openapi_types.UUID           `json:"id"`
			MaxConcurrentBorrows int                          `json:"maxConcurrentBorrows"`
			OwnerUserId          openapi_types.UUID           `json:"ownerUserId"`
			Status               ShareUpdate200DataStatus     `json:"status"`
			TitleOverride        *string                      `json:"titleOverride,omitempty"`
			UpdatedAt            time.Time                    `json:"updatedAt"`
			Visibility           ShareUpdate200DataVisibility `json:"visibility"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string               `json:"message,omitempty"`
		Status  ShareUpdate401Status  `json:"status"`
		Success ShareUpdate401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string               `json:"message,omitempty"`
		Status  ShareUpdate403Status  `json:"status"`
		Success ShareUpdate403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string               `json:"message,omitempty"`
		Status  ShareUpdate404Status  `json:"status"`
		Success ShareUpdate404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string               `json:"message,omitempty"`
		Status  ShareUpdate500Status  `json:"status"`
		Success ShareUpdate500Success `json:"success"`
	}
}
type ShareUpdate200DataStatus string
type ShareUpdate200DataVisibility string
type ShareUpdate401Status float32
type ShareUpdate401Success bool
type ShareUpdate403Status float32
type ShareUpdate403Success bool
type ShareUpdate404Status float32
type ShareUpdate404Success bool
type ShareUpdate500Status float32
type ShareUpdate500Success bool

// Status returns HTTPResponse.Status
func (r ShareUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareBorrowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data struct {
			BorrowerUserId      openapi_types.UUID       `json:"borrowerUserId"`
			CreatedAt           time.Time                `json:"createdAt"`
			DueAt               time.Time                `json:"dueAt"`
			ExpiredAt           *time.Time               `json:"expiredAt,omitempty"`
			Id                  openapi_types.UUID       `json:"id"`
			LegalAcknowledgedAt time.Time                `json:"legalAcknowledgedAt"`
			ReturnedAt          *time.Time               `json:"returnedAt,omitempty"`
			ShareId             openapi_types.UUID       `json:"shareId"`
			StartedAt           time.Time                `json:"startedAt"`
			Status              ShareBorrow201DataStatus `json:"status"`
			UpdatedAt           time.Time                `json:"updatedAt"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string               `json:"message,omitempty"`
		Status  ShareBorrow401Status  `json:"status"`
		Success ShareBorrow401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string               `json:"message,omitempty"`
		Status  ShareBorrow403Status  `json:"status"`
		Success ShareBorrow403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string               `json:"message,omitempty"`
		Status  ShareBorrow404Status  `json:"status"`
		Success ShareBorrow404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string               `json:"message,omitempty"`
		Status  ShareBorrow500Status  `json:"status"`
		Success ShareBorrow500Success `json:"success"`
	}
}
type ShareBorrow201DataStatus string
type ShareBorrow401Status float32
type ShareBorrow401Success bool
type ShareBorrow403Status float32
type ShareBorrow403Success bool
type ShareBorrow404Status float32
type ShareBorrow404Success bool
type ShareBorrow500Status float32
type ShareBorrow500Success bool

// Status returns HTTPResponse.Status
func (r ShareBorrowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareBorrowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareKillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string             `json:"message,omitempty"`
		Status  ShareKill401Status  `json:"status"`
		Success ShareKill401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string             `json:"message,omitempty"`
		Status  ShareKill403Status  `json:"status"`
		Success ShareKill403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string             `json:"message,omitempty"`
		Status  ShareKill404Status  `json:"status"`
		Success ShareKill404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string             `json:"message,omitempty"`
		Status  ShareKill500Status  `json:"status"`
		Success ShareKill500Success `json:"success"`
	}
}
type ShareKill401Status float32
type ShareKill401Success bool
type ShareKill403Status float32
type ShareKill403Success bool
type ShareKill404Status float32
type ShareKill404Success bool
type ShareKill500Status float32
type ShareKill500Success bool

// Status returns HTTPResponse.Status
func (r ShareKillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareKillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareCreateReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data struct {
			CreatedAt        time.Time                      `json:"createdAt"`
			Details          *string                        `json:"details,omitempty"`
			Id               openapi_types.UUID             `json:"id"`
			Reason           ShareCreateReport201DataReason `json:"reason"`
			ReporterUserId   openapi_types.UUID             `json:"reporterUserId"`
			ResolutionNote   *string                        `json:"resolutionNote,omitempty"`
			ReviewedAt       *time.Time                     `json:"reviewedAt,omitempty"`
			ReviewedByUserId *openapi_types.UUID            `json:"reviewedByUserId,omitempty"`
			ShareId          openapi_types.UUID             `json:"shareId"`
			Status           ShareCreateReport201DataStatus `json:"status"`
			UpdatedAt        time.Time                      `json:"updatedAt"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareCreateReport401Status  `json:"status"`
		Success ShareCreateReport401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareCreateReport403Status  `json:"status"`
		Success ShareCreateReport403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareCreateReport404Status  `json:"status"`
		Success ShareCreateReport404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareCreateReport500Status  `json:"status"`
		Success ShareCreateReport500Success `json:"success"`
	}
}
type ShareCreateReport201DataReason string
type ShareCreateReport201DataStatus string
type ShareCreateReport401Status float32
type ShareCreateReport401Success bool
type ShareCreateReport403Status float32
type ShareCreateReport403Success bool
type ShareCreateReport404Status float32
type ShareCreateReport404Success bool
type ShareCreateReport500Status float32
type ShareCreateReport500Success bool

// Status returns HTTPResponse.Status
func (r ShareCreateReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareCreateReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareRestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			BorrowDurationHours  int                           `json:"borrowDurationHours"`
			CreatedAt            time.Time                     `json:"createdAt"`
			DeletedAt            *time.Time                    `json:"deletedAt,omitempty"`
			Description          *string                       `json:"description,omitempty"`
			EbookId              openapi_types.UUID            `json:"ebookId"`
			Id                   openapi_types.UUID            `json:"id"`
			MaxConcurrentBorrows int                           `json:"maxConcurrentBorrows"`
			OwnerUserId          openapi_types.UUID            `json:"ownerUserId"`
			Status               ShareRestore200DataStatus     `json:"status"`
			TitleOverride        *string                       `json:"titleOverride,omitempty"`
			UpdatedAt            time.Time                     `json:"updatedAt"`
			Visibility           ShareRestore200DataVisibility `json:"visibility"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareRestore401Status  `json:"status"`
		Success ShareRestore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareRestore403Status  `json:"status"`
		Success ShareRestore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareRestore404Status  `json:"status"`
		Success ShareRestore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                `json:"message,omitempty"`
		Status  ShareRestore500Status  `json:"status"`
		Success ShareRestore500Success `json:"success"`
	}
}
type ShareRestore200DataStatus string
type ShareRestore200DataVisibility string
type ShareRestore401Status float32
type ShareRestore401Success bool
type ShareRestore403Status float32
type ShareRestore403Success bool
type ShareRestore404Status float32
type ShareRestore404Success bool
type ShareRestore500Status float32
type ShareRestore500Success bool

// Status returns HTTPResponse.Status
func (r ShareRestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareRestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareUpsertReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt  time.Time          `json:"createdAt"`
			DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
			Id         openapi_types.UUID `json:"id"`
			Rating     int                `json:"rating"`
			ReviewText *string            `json:"reviewText,omitempty"`
			ShareId    openapi_types.UUID `json:"shareId"`
			UpdatedAt  time.Time          `json:"updatedAt"`
			UserId     openapi_types.UUID `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareUpsertReview401Status  `json:"status"`
		Success ShareUpsertReview401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareUpsertReview403Status  `json:"status"`
		Success ShareUpsertReview403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareUpsertReview404Status  `json:"status"`
		Success ShareUpsertReview404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                     `json:"message,omitempty"`
		Status  ShareUpsertReview500Status  `json:"status"`
		Success ShareUpsertReview500Success `json:"success"`
	}
}
type ShareUpsertReview401Status float32
type ShareUpsertReview401Success bool
type ShareUpsertReview403Status float32
type ShareUpsertReview403Success bool
type ShareUpsertReview404Status float32
type ShareUpsertReview404Success bool
type ShareUpsertReview500Status float32
type ShareUpsertReview500Success bool

// Status returns HTTPResponse.Status
func (r ShareUpsertReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareUpsertReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncListEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			BaseVersion     *int                            `json:"baseVersion,omitempty"`
			ClientTimestamp time.Time                       `json:"clientTimestamp"`
			CreatedAt       time.Time                       `json:"createdAt"`
			EntityId        openapi_types.UUID              `json:"entityId"`
			EntityType      SyncListEvents200DataEntityType `json:"entityType"`
			Id              openapi_types.UUID              `json:"id"`
			IdempotencyKey  string                          `json:"idempotencyKey"`
			Operation       SyncListEvents200DataOperation  `json:"operation"`
			Payload         *map[string]*interface{}        `json:"payload,omitempty"`
			ServerTimestamp time.Time                       `json:"serverTimestamp"`
			UserId          openapi_types.UUID              `json:"userId"`
		} `json:"data"`
		Limit      *float32                `json:"limit,omitempty"`
		Message    *string                 `json:"message,omitempty"`
		Page       float32                 `json:"page"`
		Status     SyncListEvents200Status `json:"status"`
		Success    *bool                   `json:"success,omitempty"`
		Total      *float32                `json:"total,omitempty"`
		TotalPages *float32                `json:"totalPages,omitempty"`
	}
	JSON401 *struct {
		Message *string                  `json:"message,omitempty"`
		Status  SyncListEvents401Status  `json:"status"`
		Success SyncListEvents401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                  `json:"message,omitempty"`
		Status  SyncListEvents403Status  `json:"status"`
		Success SyncListEvents403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                  `json:"message,omitempty"`
		Status  SyncListEvents404Status  `json:"status"`
		Success SyncListEvents404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                  `json:"message,omitempty"`
		Status  SyncListEvents500Status  `json:"status"`
		Success SyncListEvents500Success `json:"success"`
	}
}
type SyncListEvents200DataEntityType string
type SyncListEvents200DataOperation string
type SyncListEvents200Status float32
type SyncListEvents401Status float32
type SyncListEvents401Success bool
type SyncListEvents403Status float32
type SyncListEvents403Success bool
type SyncListEvents404Status float32
type SyncListEvents404Success bool
type SyncListEvents500Status float32
type SyncListEvents500Success bool

// Status returns HTTPResponse.Status
func (r SyncListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncStoreEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data struct {
			BaseVersion     *int                            `json:"baseVersion,omitempty"`
			ClientTimestamp time.Time                       `json:"clientTimestamp"`
			CreatedAt       time.Time                       `json:"createdAt"`
			EntityId        openapi_types.UUID              `json:"entityId"`
			EntityType      SyncStoreEvent201DataEntityType `json:"entityType"`
			Id              openapi_types.UUID              `json:"id"`
			IdempotencyKey  string                          `json:"idempotencyKey"`
			Operation       SyncStoreEvent201DataOperation  `json:"operation"`
			Payload         *map[string]*interface{}        `json:"payload,omitempty"`
			ServerTimestamp time.Time                       `json:"serverTimestamp"`
			UserId          openapi_types.UUID              `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                  `json:"message,omitempty"`
		Status  SyncStoreEvent401Status  `json:"status"`
		Success SyncStoreEvent401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                  `json:"message,omitempty"`
		Status  SyncStoreEvent403Status  `json:"status"`
		Success SyncStoreEvent403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                  `json:"message,omitempty"`
		Status  SyncStoreEvent404Status  `json:"status"`
		Success SyncStoreEvent404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                  `json:"message,omitempty"`
		Status  SyncStoreEvent500Status  `json:"status"`
		Success SyncStoreEvent500Success `json:"success"`
	}
}
type SyncStoreEvent201DataEntityType string
type SyncStoreEvent201DataOperation string
type SyncStoreEvent401Status float32
type SyncStoreEvent401Success bool
type SyncStoreEvent403Status float32
type SyncStoreEvent403Success bool
type SyncStoreEvent404Status float32
type SyncStoreEvent404Success bool
type SyncStoreEvent500Status float32
type SyncStoreEvent500Success bool

// Status returns HTTPResponse.Status
func (r SyncStoreEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncStoreEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserGetManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		} `json:"data"`
		Limit      *float32             `json:"limit,omitempty"`
		Message    *string              `json:"message,omitempty"`
		Page       float32              `json:"page"`
		Status     UserGetMany200Status `json:"status"`
		Success    *bool                `json:"success,omitempty"`
		Total      *float32             `json:"total,omitempty"`
		TotalPages *float32             `json:"totalPages,omitempty"`
	}
	JSON401 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserGetMany401Status  `json:"status"`
		Success UserGetMany401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserGetMany403Status  `json:"status"`
		Success UserGetMany403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserGetMany404Status  `json:"status"`
		Success UserGetMany404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserGetMany500Status  `json:"status"`
		Success UserGetMany500Success `json:"success"`
	}
}
type UserGetMany200Status float32
type UserGetMany401Status float32
type UserGetMany401Success bool
type UserGetMany403Status float32
type UserGetMany403Success bool
type UserGetMany404Status float32
type UserGetMany404Success bool
type UserGetMany500Status float32
type UserGetMany500Success bool

// Status returns HTTPResponse.Status
func (r UserGetManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserGetManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string             `json:"message,omitempty"`
		Status  UserStore401Status  `json:"status"`
		Success UserStore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string             `json:"message,omitempty"`
		Status  UserStore403Status  `json:"status"`
		Success UserStore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string             `json:"message,omitempty"`
		Status  UserStore404Status  `json:"status"`
		Success UserStore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string             `json:"message,omitempty"`
		Status  UserStore500Status  `json:"status"`
		Success UserStore500Success `json:"success"`
	}
}
type UserStore401Status float32
type UserStore401Success bool
type UserStore403Status float32
type UserStore403Success bool
type UserStore404Status float32
type UserStore404Success bool
type UserStore500Status float32
type UserStore500Success bool

// Status returns HTTPResponse.Status
func (r UserStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderGetUserPreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt         time.Time                                        `json:"createdAt"`
			ReadingMode       ReaderGetUserPreferences200DataReadingMode       `json:"readingMode"`
			RowVersion        int                                              `json:"rowVersion"`
			ThemeMode         ReaderGetUserPreferences200DataThemeMode         `json:"themeMode"`
			ThemeOverrides    map[string]string                                `json:"themeOverrides"`
			TypographyProfile ReaderGetUserPreferences200DataTypographyProfile `json:"typographyProfile"`
			UpdatedAt         time.Time                                        `json:"updatedAt"`
			UserId            openapi_types.UUID                               `json:"userId"`
			ZenRestoreOnOpen  bool                                             `json:"zenRestoreOnOpen"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderGetUserPreferences401Status  `json:"status"`
		Success ReaderGetUserPreferences401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderGetUserPreferences403Status  `json:"status"`
		Success ReaderGetUserPreferences403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderGetUserPreferences404Status  `json:"status"`
		Success ReaderGetUserPreferences404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderGetUserPreferences500Status  `json:"status"`
		Success ReaderGetUserPreferences500Success `json:"success"`
	}
}
type ReaderGetUserPreferences200DataReadingMode string
type ReaderGetUserPreferences200DataThemeMode string
type ReaderGetUserPreferences200DataTypographyProfile string
type ReaderGetUserPreferences401Status float32
type ReaderGetUserPreferences401Success bool
type ReaderGetUserPreferences403Status float32
type ReaderGetUserPreferences403Success bool
type ReaderGetUserPreferences404Status float32
type ReaderGetUserPreferences404Success bool
type ReaderGetUserPreferences500Status float32
type ReaderGetUserPreferences500Success bool

// Status returns HTTPResponse.Status
func (r ReaderGetUserPreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderGetUserPreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderPatchUserPreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt         time.Time                                          `json:"createdAt"`
			ReadingMode       ReaderPatchUserPreferences200DataReadingMode       `json:"readingMode"`
			RowVersion        int                                                `json:"rowVersion"`
			ThemeMode         ReaderPatchUserPreferences200DataThemeMode         `json:"themeMode"`
			ThemeOverrides    map[string]string                                  `json:"themeOverrides"`
			TypographyProfile ReaderPatchUserPreferences200DataTypographyProfile `json:"typographyProfile"`
			UpdatedAt         time.Time                                          `json:"updatedAt"`
			UserId            openapi_types.UUID                                 `json:"userId"`
			ZenRestoreOnOpen  bool                                               `json:"zenRestoreOnOpen"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderPatchUserPreferences401Status  `json:"status"`
		Success ReaderPatchUserPreferences401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderPatchUserPreferences403Status  `json:"status"`
		Success ReaderPatchUserPreferences403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderPatchUserPreferences404Status  `json:"status"`
		Success ReaderPatchUserPreferences404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderPatchUserPreferences500Status  `json:"status"`
		Success ReaderPatchUserPreferences500Success `json:"success"`
	}
}
type ReaderPatchUserPreferences200DataReadingMode string
type ReaderPatchUserPreferences200DataThemeMode string
type ReaderPatchUserPreferences200DataTypographyProfile string
type ReaderPatchUserPreferences401Status float32
type ReaderPatchUserPreferences401Success bool
type ReaderPatchUserPreferences403Status float32
type ReaderPatchUserPreferences403Success bool
type ReaderPatchUserPreferences404Status float32
type ReaderPatchUserPreferences404Success bool
type ReaderPatchUserPreferences500Status float32
type ReaderPatchUserPreferences500Success bool

// Status returns HTTPResponse.Status
func (r ReaderPatchUserPreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderPatchUserPreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderGetUserReaderStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt       time.Time                                  `json:"createdAt"`
			CurrentEbookId  *openapi_types.UUID                        `json:"currentEbookId,omitempty"`
			CurrentLocation *string                                    `json:"currentLocation,omitempty"`
			LastOpenedAt    *time.Time                                 `json:"lastOpenedAt,omitempty"`
			ReadingMode     ReaderGetUserReaderState200DataReadingMode `json:"readingMode"`
			RowVersion      int                                        `json:"rowVersion"`
			UpdatedAt       time.Time                                  `json:"updatedAt"`
			UserId          openapi_types.UUID                         `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderGetUserReaderState401Status  `json:"status"`
		Success ReaderGetUserReaderState401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderGetUserReaderState403Status  `json:"status"`
		Success ReaderGetUserReaderState403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderGetUserReaderState404Status  `json:"status"`
		Success ReaderGetUserReaderState404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                            `json:"message,omitempty"`
		Status  ReaderGetUserReaderState500Status  `json:"status"`
		Success ReaderGetUserReaderState500Success `json:"success"`
	}
}
type ReaderGetUserReaderState200DataReadingMode string
type ReaderGetUserReaderState401Status float32
type ReaderGetUserReaderState401Success bool
type ReaderGetUserReaderState403Status float32
type ReaderGetUserReaderState403Success bool
type ReaderGetUserReaderState404Status float32
type ReaderGetUserReaderState404Success bool
type ReaderGetUserReaderState500Status float32
type ReaderGetUserReaderState500Success bool

// Status returns HTTPResponse.Status
func (r ReaderGetUserReaderStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderGetUserReaderStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReaderPatchUserReaderStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt       time.Time                                    `json:"createdAt"`
			CurrentEbookId  *openapi_types.UUID                          `json:"currentEbookId,omitempty"`
			CurrentLocation *string                                      `json:"currentLocation,omitempty"`
			LastOpenedAt    *time.Time                                   `json:"lastOpenedAt,omitempty"`
			ReadingMode     ReaderPatchUserReaderState200DataReadingMode `json:"readingMode"`
			RowVersion      int                                          `json:"rowVersion"`
			UpdatedAt       time.Time                                    `json:"updatedAt"`
			UserId          openapi_types.UUID                           `json:"userId"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderPatchUserReaderState401Status  `json:"status"`
		Success ReaderPatchUserReaderState401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderPatchUserReaderState403Status  `json:"status"`
		Success ReaderPatchUserReaderState403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderPatchUserReaderState404Status  `json:"status"`
		Success ReaderPatchUserReaderState404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                              `json:"message,omitempty"`
		Status  ReaderPatchUserReaderState500Status  `json:"status"`
		Success ReaderPatchUserReaderState500Success `json:"success"`
	}
}
type ReaderPatchUserReaderState200DataReadingMode string
type ReaderPatchUserReaderState401Status float32
type ReaderPatchUserReaderState401Success bool
type ReaderPatchUserReaderState403Status float32
type ReaderPatchUserReaderState403Success bool
type ReaderPatchUserReaderState404Status float32
type ReaderPatchUserReaderState404Success bool
type ReaderPatchUserReaderState500Status float32
type ReaderPatchUserReaderState500Success bool

// Status returns HTTPResponse.Status
func (r ReaderPatchUserReaderStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReaderPatchUserReaderStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserDestroy401Status  `json:"status"`
		Success UserDestroy401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserDestroy403Status  `json:"status"`
		Success UserDestroy403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserDestroy404Status  `json:"status"`
		Success UserDestroy404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserDestroy500Status  `json:"status"`
		Success UserDestroy500Success `json:"success"`
	}
}
type UserDestroy401Status float32
type UserDestroy401Success bool
type UserDestroy403Status float32
type UserDestroy403Success bool
type UserDestroy404Status float32
type UserDestroy404Success bool
type UserDestroy500Status float32
type UserDestroy500Success bool

// Status returns HTTPResponse.Status
func (r UserDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserGetById401Status  `json:"status"`
		Success UserGetById401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserGetById403Status  `json:"status"`
		Success UserGetById403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserGetById404Status  `json:"status"`
		Success UserGetById404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserGetById500Status  `json:"status"`
		Success UserGetById500Success `json:"success"`
	}
}
type UserGetById401Status float32
type UserGetById401Success bool
type UserGetById403Status float32
type UserGetById403Success bool
type UserGetById404Status float32
type UserGetById404Success bool
type UserGetById500Status float32
type UserGetById500Success bool

// Status returns HTTPResponse.Status
func (r UserGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string              `json:"message,omitempty"`
		Status  UserUpdate401Status  `json:"status"`
		Success UserUpdate401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string              `json:"message,omitempty"`
		Status  UserUpdate403Status  `json:"status"`
		Success UserUpdate403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string              `json:"message,omitempty"`
		Status  UserUpdate404Status  `json:"status"`
		Success UserUpdate404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string              `json:"message,omitempty"`
		Status  UserUpdate500Status  `json:"status"`
		Success UserUpdate500Success `json:"success"`
	}
}
type UserUpdate401Status float32
type UserUpdate401Success bool
type UserUpdate403Status float32
type UserUpdate403Success bool
type UserUpdate404Status float32
type UserUpdate404Success bool
type UserUpdate500Status float32
type UserUpdate500Success bool

// Status returns HTTPResponse.Status
func (r UserUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserKillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string            `json:"message,omitempty"`
		Status  UserKill401Status  `json:"status"`
		Success UserKill401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string            `json:"message,omitempty"`
		Status  UserKill403Status  `json:"status"`
		Success UserKill403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string            `json:"message,omitempty"`
		Status  UserKill404Status  `json:"status"`
		Success UserKill404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string            `json:"message,omitempty"`
		Status  UserKill500Status  `json:"status"`
		Success UserKill500Success `json:"success"`
	}
}
type UserKill401Status float32
type UserKill401Success bool
type UserKill403Status float32
type UserKill403Success bool
type UserKill404Status float32
type UserKill404Success bool
type UserKill500Status float32
type UserKill500Success bool

// Status returns HTTPResponse.Status
func (r UserKillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserKillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserRestoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserRestore401Status  `json:"status"`
		Success UserRestore401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserRestore403Status  `json:"status"`
		Success UserRestore403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserRestore404Status  `json:"status"`
		Success UserRestore404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string               `json:"message,omitempty"`
		Status  UserRestore500Status  `json:"status"`
		Success UserRestore500Success `json:"success"`
	}
}
type UserRestore401Status float32
type UserRestore401Success bool
type UserRestore403Status float32
type UserRestore403Success bool
type UserRestore404Status float32
type UserRestore404Success bool
type UserRestore500Status float32
type UserRestore500Success bool

// Status returns HTTPResponse.Status
func (r UserRestoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserRestoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthGetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Checks struct {
				Database struct {
					Error        *string                                    `json:"error,omitempty"`
					ResponseTime string                                     `json:"response_time"`
					Status       HealthGetHealth200DataChecksDatabaseStatus `json:"status"`
				} `json:"database"`
				Redis *struct {
					Error        *string                                 `json:"error,omitempty"`
					ResponseTime string                                  `json:"response_time"`
					Status       HealthGetHealth200DataChecksRedisStatus `json:"status"`
				} `json:"redis,omitempty"`
			} `json:"checks"`
			Environment string                       `json:"environment"`
			Status      HealthGetHealth200DataStatus `json:"status"`
			Timestamp   time.Time                    `json:"timestamp"`
		} `json:"data"`
		Message *string `json:"message,omitempty"`
		Status  *int    `json:"status,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON401 *struct {
		Message *string                   `json:"message,omitempty"`
		Status  HealthGetHealth401Status  `json:"status"`
		Success HealthGetHealth401Success `json:"success"`
	}
	JSON403 *struct {
		Message *string                   `json:"message,omitempty"`
		Status  HealthGetHealth403Status  `json:"status"`
		Success HealthGetHealth403Success `json:"success"`
	}
	JSON404 *struct {
		Message *string                   `json:"message,omitempty"`
		Status  HealthGetHealth404Status  `json:"status"`
		Success HealthGetHealth404Success `json:"success"`
	}
	JSON500 *struct {
		Message *string                   `json:"message,omitempty"`
		Status  HealthGetHealth500Status  `json:"status"`
		Success HealthGetHealth500Success `json:"success"`
	}
}
type HealthGetHealth200DataChecksDatabaseStatus string
type HealthGetHealth200DataChecksRedisStatus string
type HealthGetHealth200DataStatus string
type HealthGetHealth401Status float32
type HealthGetHealth401Success bool
type HealthGetHealth403Status float32
type HealthGetHealth403Success bool
type HealthGetHealth404Status float32
type HealthGetHealth404Success bool
type HealthGetHealth500Status float32
type HealthGetHealth500Success bool

// Status returns HTTPResponse.Status
func (r HealthGetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthGetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ReaderAnnotationsGetManyWithResponse request returning *ReaderAnnotationsGetManyResponse
func (c *ClientWithResponses) ReaderAnnotationsGetManyWithResponse(ctx context.Context, params *ReaderAnnotationsGetManyParams, reqEditors ...RequestEditorFn) (*ReaderAnnotationsGetManyResponse, error) {
	rsp, err := c.ReaderAnnotationsGetMany(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsGetManyResponse(rsp)
}

// ReaderAnnotationsStoreWithBodyWithResponse request with arbitrary body returning *ReaderAnnotationsStoreResponse
func (c *ClientWithResponses) ReaderAnnotationsStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderAnnotationsStoreResponse, error) {
	rsp, err := c.ReaderAnnotationsStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsStoreResponse(rsp)
}

func (c *ClientWithResponses) ReaderAnnotationsStoreWithResponse(ctx context.Context, body ReaderAnnotationsStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderAnnotationsStoreResponse, error) {
	rsp, err := c.ReaderAnnotationsStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsStoreResponse(rsp)
}

// ReaderAnnotationsDestroyWithResponse request returning *ReaderAnnotationsDestroyResponse
func (c *ClientWithResponses) ReaderAnnotationsDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderAnnotationsDestroyResponse, error) {
	rsp, err := c.ReaderAnnotationsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsDestroyResponse(rsp)
}

// ReaderAnnotationsGetByIdWithResponse request returning *ReaderAnnotationsGetByIdResponse
func (c *ClientWithResponses) ReaderAnnotationsGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsGetByIdParams, reqEditors ...RequestEditorFn) (*ReaderAnnotationsGetByIdResponse, error) {
	rsp, err := c.ReaderAnnotationsGetById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsGetByIdResponse(rsp)
}

// ReaderAnnotationsUpdateWithBodyWithResponse request with arbitrary body returning *ReaderAnnotationsUpdateResponse
func (c *ClientWithResponses) ReaderAnnotationsUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderAnnotationsUpdateResponse, error) {
	rsp, err := c.ReaderAnnotationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ReaderAnnotationsUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body ReaderAnnotationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderAnnotationsUpdateResponse, error) {
	rsp, err := c.ReaderAnnotationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsUpdateResponse(rsp)
}

// ReaderAnnotationsKillWithResponse request returning *ReaderAnnotationsKillResponse
func (c *ClientWithResponses) ReaderAnnotationsKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderAnnotationsKillResponse, error) {
	rsp, err := c.ReaderAnnotationsKill(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsKillResponse(rsp)
}

// ReaderAnnotationsRestoreWithBodyWithResponse request with arbitrary body returning *ReaderAnnotationsRestoreResponse
func (c *ClientWithResponses) ReaderAnnotationsRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderAnnotationsRestoreResponse, error) {
	rsp, err := c.ReaderAnnotationsRestoreWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsRestoreResponse(rsp)
}

func (c *ClientWithResponses) ReaderAnnotationsRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderAnnotationsRestoreParams, body ReaderAnnotationsRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderAnnotationsRestoreResponse, error) {
	rsp, err := c.ReaderAnnotationsRestore(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderAnnotationsRestoreResponse(rsp)
}

// AuthGoogleLoginWithResponse request returning *AuthGoogleLoginResponse
func (c *ClientWithResponses) AuthGoogleLoginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthGoogleLoginResponse, error) {
	rsp, err := c.AuthGoogleLogin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthGoogleLoginResponse(rsp)
}

// AuthGoogleCallbackWithResponse request returning *AuthGoogleCallbackResponse
func (c *ClientWithResponses) AuthGoogleCallbackWithResponse(ctx context.Context, params *AuthGoogleCallbackParams, reqEditors ...RequestEditorFn) (*AuthGoogleCallbackResponse, error) {
	rsp, err := c.AuthGoogleCallback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthGoogleCallbackResponse(rsp)
}

// AuthGoogleDevicePollWithBodyWithResponse request with arbitrary body returning *AuthGoogleDevicePollResponse
func (c *ClientWithResponses) AuthGoogleDevicePollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthGoogleDevicePollResponse, error) {
	rsp, err := c.AuthGoogleDevicePollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthGoogleDevicePollResponse(rsp)
}

func (c *ClientWithResponses) AuthGoogleDevicePollWithResponse(ctx context.Context, body AuthGoogleDevicePollJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthGoogleDevicePollResponse, error) {
	rsp, err := c.AuthGoogleDevicePoll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthGoogleDevicePollResponse(rsp)
}

// AuthGoogleDeviceStartWithBodyWithResponse request with arbitrary body returning *AuthGoogleDeviceStartResponse
func (c *ClientWithResponses) AuthGoogleDeviceStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthGoogleDeviceStartResponse, error) {
	rsp, err := c.AuthGoogleDeviceStartWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthGoogleDeviceStartResponse(rsp)
}

func (c *ClientWithResponses) AuthGoogleDeviceStartWithResponse(ctx context.Context, body AuthGoogleDeviceStartJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthGoogleDeviceStartResponse, error) {
	rsp, err := c.AuthGoogleDeviceStart(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthGoogleDeviceStartResponse(rsp)
}

// AuthLoginWithBodyWithResponse request with arbitrary body returning *AuthLoginResponse
func (c *ClientWithResponses) AuthLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error) {
	rsp, err := c.AuthLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginResponse(rsp)
}

func (c *ClientWithResponses) AuthLoginWithResponse(ctx context.Context, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error) {
	rsp, err := c.AuthLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginResponse(rsp)
}

// AuthLogoutWithBodyWithResponse request with arbitrary body returning *AuthLogoutResponse
func (c *ClientWithResponses) AuthLogoutWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLogoutResponse, error) {
	rsp, err := c.AuthLogoutWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLogoutResponse(rsp)
}

func (c *ClientWithResponses) AuthLogoutWithResponse(ctx context.Context, body AuthLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLogoutResponse, error) {
	rsp, err := c.AuthLogout(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLogoutResponse(rsp)
}

// AuthLogoutAllWithBodyWithResponse request with arbitrary body returning *AuthLogoutAllResponse
func (c *ClientWithResponses) AuthLogoutAllWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLogoutAllResponse, error) {
	rsp, err := c.AuthLogoutAllWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLogoutAllResponse(rsp)
}

func (c *ClientWithResponses) AuthLogoutAllWithResponse(ctx context.Context, body AuthLogoutAllJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLogoutAllResponse, error) {
	rsp, err := c.AuthLogoutAll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLogoutAllResponse(rsp)
}

// AuthMeWithResponse request returning *AuthMeResponse
func (c *ClientWithResponses) AuthMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthMeResponse, error) {
	rsp, err := c.AuthMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthMeResponse(rsp)
}

// AuthRefreshWithBodyWithResponse request with arbitrary body returning *AuthRefreshResponse
func (c *ClientWithResponses) AuthRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRefreshResponse, error) {
	rsp, err := c.AuthRefreshWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRefreshResponse(rsp)
}

func (c *ClientWithResponses) AuthRefreshWithResponse(ctx context.Context, body AuthRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRefreshResponse, error) {
	rsp, err := c.AuthRefresh(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRefreshResponse(rsp)
}

// AuthRegisterWithBodyWithResponse request with arbitrary body returning *AuthRegisterResponse
func (c *ClientWithResponses) AuthRegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error) {
	rsp, err := c.AuthRegisterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRegisterResponse(rsp)
}

func (c *ClientWithResponses) AuthRegisterWithResponse(ctx context.Context, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error) {
	rsp, err := c.AuthRegister(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRegisterResponse(rsp)
}

// AuthResendVerificationWithBodyWithResponse request with arbitrary body returning *AuthResendVerificationResponse
func (c *ClientWithResponses) AuthResendVerificationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthResendVerificationResponse, error) {
	rsp, err := c.AuthResendVerificationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthResendVerificationResponse(rsp)
}

func (c *ClientWithResponses) AuthResendVerificationWithResponse(ctx context.Context, body AuthResendVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthResendVerificationResponse, error) {
	rsp, err := c.AuthResendVerification(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthResendVerificationResponse(rsp)
}

// AuthVerifyEmailWithBodyWithResponse request with arbitrary body returning *AuthVerifyEmailResponse
func (c *ClientWithResponses) AuthVerifyEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error) {
	rsp, err := c.AuthVerifyEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthVerifyEmailResponse(rsp)
}

func (c *ClientWithResponses) AuthVerifyEmailWithResponse(ctx context.Context, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error) {
	rsp, err := c.AuthVerifyEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthVerifyEmailResponse(rsp)
}

// ReaderBookmarksGetManyWithResponse request returning *ReaderBookmarksGetManyResponse
func (c *ClientWithResponses) ReaderBookmarksGetManyWithResponse(ctx context.Context, params *ReaderBookmarksGetManyParams, reqEditors ...RequestEditorFn) (*ReaderBookmarksGetManyResponse, error) {
	rsp, err := c.ReaderBookmarksGetMany(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksGetManyResponse(rsp)
}

// ReaderBookmarksStoreWithBodyWithResponse request with arbitrary body returning *ReaderBookmarksStoreResponse
func (c *ClientWithResponses) ReaderBookmarksStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderBookmarksStoreResponse, error) {
	rsp, err := c.ReaderBookmarksStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksStoreResponse(rsp)
}

func (c *ClientWithResponses) ReaderBookmarksStoreWithResponse(ctx context.Context, body ReaderBookmarksStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderBookmarksStoreResponse, error) {
	rsp, err := c.ReaderBookmarksStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksStoreResponse(rsp)
}

// ReaderBookmarksDestroyWithResponse request returning *ReaderBookmarksDestroyResponse
func (c *ClientWithResponses) ReaderBookmarksDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderBookmarksDestroyResponse, error) {
	rsp, err := c.ReaderBookmarksDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksDestroyResponse(rsp)
}

// ReaderBookmarksGetByIdWithResponse request returning *ReaderBookmarksGetByIdResponse
func (c *ClientWithResponses) ReaderBookmarksGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksGetByIdParams, reqEditors ...RequestEditorFn) (*ReaderBookmarksGetByIdResponse, error) {
	rsp, err := c.ReaderBookmarksGetById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksGetByIdResponse(rsp)
}

// ReaderBookmarksUpdateWithBodyWithResponse request with arbitrary body returning *ReaderBookmarksUpdateResponse
func (c *ClientWithResponses) ReaderBookmarksUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderBookmarksUpdateResponse, error) {
	rsp, err := c.ReaderBookmarksUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksUpdateResponse(rsp)
}

func (c *ClientWithResponses) ReaderBookmarksUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body ReaderBookmarksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderBookmarksUpdateResponse, error) {
	rsp, err := c.ReaderBookmarksUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksUpdateResponse(rsp)
}

// ReaderBookmarksKillWithResponse request returning *ReaderBookmarksKillResponse
func (c *ClientWithResponses) ReaderBookmarksKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderBookmarksKillResponse, error) {
	rsp, err := c.ReaderBookmarksKill(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksKillResponse(rsp)
}

// ReaderBookmarksRestoreWithBodyWithResponse request with arbitrary body returning *ReaderBookmarksRestoreResponse
func (c *ClientWithResponses) ReaderBookmarksRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderBookmarksRestoreResponse, error) {
	rsp, err := c.ReaderBookmarksRestoreWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksRestoreResponse(rsp)
}

func (c *ClientWithResponses) ReaderBookmarksRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderBookmarksRestoreParams, body ReaderBookmarksRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderBookmarksRestoreResponse, error) {
	rsp, err := c.ReaderBookmarksRestore(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderBookmarksRestoreResponse(rsp)
}

// ShareReturnBorrowWithBodyWithResponse request with arbitrary body returning *ShareReturnBorrowResponse
func (c *ClientWithResponses) ShareReturnBorrowWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareReturnBorrowResponse, error) {
	rsp, err := c.ShareReturnBorrowWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareReturnBorrowResponse(rsp)
}

func (c *ClientWithResponses) ShareReturnBorrowWithResponse(ctx context.Context, id openapi_types.UUID, body ShareReturnBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareReturnBorrowResponse, error) {
	rsp, err := c.ShareReturnBorrow(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareReturnBorrowResponse(rsp)
}

// EbookGetManyWithResponse request returning *EbookGetManyResponse
func (c *ClientWithResponses) EbookGetManyWithResponse(ctx context.Context, params *EbookGetManyParams, reqEditors ...RequestEditorFn) (*EbookGetManyResponse, error) {
	rsp, err := c.EbookGetMany(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookGetManyResponse(rsp)
}

// EbookStoreWithBodyWithResponse request with arbitrary body returning *EbookStoreResponse
func (c *ClientWithResponses) EbookStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EbookStoreResponse, error) {
	rsp, err := c.EbookStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookStoreResponse(rsp)
}

func (c *ClientWithResponses) EbookStoreWithResponse(ctx context.Context, body EbookStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EbookStoreResponse, error) {
	rsp, err := c.EbookStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookStoreResponse(rsp)
}

// EbookDestroyWithResponse request returning *EbookDestroyResponse
func (c *ClientWithResponses) EbookDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*EbookDestroyResponse, error) {
	rsp, err := c.EbookDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookDestroyResponse(rsp)
}

// EbookGetByIdWithResponse request returning *EbookGetByIdResponse
func (c *ClientWithResponses) EbookGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *EbookGetByIdParams, reqEditors ...RequestEditorFn) (*EbookGetByIdResponse, error) {
	rsp, err := c.EbookGetById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookGetByIdResponse(rsp)
}

// EbookUpdateWithBodyWithResponse request with arbitrary body returning *EbookUpdateResponse
func (c *ClientWithResponses) EbookUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EbookUpdateResponse, error) {
	rsp, err := c.EbookUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookUpdateResponse(rsp)
}

func (c *ClientWithResponses) EbookUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body EbookUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EbookUpdateResponse, error) {
	rsp, err := c.EbookUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookUpdateResponse(rsp)
}

// EbookKillWithResponse request returning *EbookKillResponse
func (c *ClientWithResponses) EbookKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*EbookKillResponse, error) {
	rsp, err := c.EbookKill(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookKillResponse(rsp)
}

// EbookRemoveMetadataWithResponse request returning *EbookRemoveMetadataResponse
func (c *ClientWithResponses) EbookRemoveMetadataWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*EbookRemoveMetadataResponse, error) {
	rsp, err := c.EbookRemoveMetadata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookRemoveMetadataResponse(rsp)
}

// EbookAttachMetadataWithBodyWithResponse request with arbitrary body returning *EbookAttachMetadataResponse
func (c *ClientWithResponses) EbookAttachMetadataWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EbookAttachMetadataResponse, error) {
	rsp, err := c.EbookAttachMetadataWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookAttachMetadataResponse(rsp)
}

func (c *ClientWithResponses) EbookAttachMetadataWithResponse(ctx context.Context, id openapi_types.UUID, body EbookAttachMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*EbookAttachMetadataResponse, error) {
	rsp, err := c.EbookAttachMetadata(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookAttachMetadataResponse(rsp)
}

// EbookRestoreWithBodyWithResponse request with arbitrary body returning *EbookRestoreResponse
func (c *ClientWithResponses) EbookRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *EbookRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EbookRestoreResponse, error) {
	rsp, err := c.EbookRestoreWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookRestoreResponse(rsp)
}

func (c *ClientWithResponses) EbookRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *EbookRestoreParams, body EbookRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EbookRestoreResponse, error) {
	rsp, err := c.EbookRestore(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEbookRestoreResponse(rsp)
}

// ReaderReadingProgressGetManyWithResponse request returning *ReaderReadingProgressGetManyResponse
func (c *ClientWithResponses) ReaderReadingProgressGetManyWithResponse(ctx context.Context, params *ReaderReadingProgressGetManyParams, reqEditors ...RequestEditorFn) (*ReaderReadingProgressGetManyResponse, error) {
	rsp, err := c.ReaderReadingProgressGetMany(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressGetManyResponse(rsp)
}

// ReaderReadingProgressStoreWithBodyWithResponse request with arbitrary body returning *ReaderReadingProgressStoreResponse
func (c *ClientWithResponses) ReaderReadingProgressStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderReadingProgressStoreResponse, error) {
	rsp, err := c.ReaderReadingProgressStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressStoreResponse(rsp)
}

func (c *ClientWithResponses) ReaderReadingProgressStoreWithResponse(ctx context.Context, body ReaderReadingProgressStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderReadingProgressStoreResponse, error) {
	rsp, err := c.ReaderReadingProgressStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressStoreResponse(rsp)
}

// ReaderReadingProgressDestroyWithResponse request returning *ReaderReadingProgressDestroyResponse
func (c *ClientWithResponses) ReaderReadingProgressDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderReadingProgressDestroyResponse, error) {
	rsp, err := c.ReaderReadingProgressDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressDestroyResponse(rsp)
}

// ReaderReadingProgressGetByIdWithResponse request returning *ReaderReadingProgressGetByIdResponse
func (c *ClientWithResponses) ReaderReadingProgressGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressGetByIdParams, reqEditors ...RequestEditorFn) (*ReaderReadingProgressGetByIdResponse, error) {
	rsp, err := c.ReaderReadingProgressGetById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressGetByIdResponse(rsp)
}

// ReaderReadingProgressUpdateWithBodyWithResponse request with arbitrary body returning *ReaderReadingProgressUpdateResponse
func (c *ClientWithResponses) ReaderReadingProgressUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderReadingProgressUpdateResponse, error) {
	rsp, err := c.ReaderReadingProgressUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressUpdateResponse(rsp)
}

func (c *ClientWithResponses) ReaderReadingProgressUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body ReaderReadingProgressUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderReadingProgressUpdateResponse, error) {
	rsp, err := c.ReaderReadingProgressUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressUpdateResponse(rsp)
}

// ReaderReadingProgressKillWithResponse request returning *ReaderReadingProgressKillResponse
func (c *ClientWithResponses) ReaderReadingProgressKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ReaderReadingProgressKillResponse, error) {
	rsp, err := c.ReaderReadingProgressKill(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressKillResponse(rsp)
}

// ReaderReadingProgressRestoreWithBodyWithResponse request with arbitrary body returning *ReaderReadingProgressRestoreResponse
func (c *ClientWithResponses) ReaderReadingProgressRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderReadingProgressRestoreResponse, error) {
	rsp, err := c.ReaderReadingProgressRestoreWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressRestoreResponse(rsp)
}

func (c *ClientWithResponses) ReaderReadingProgressRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *ReaderReadingProgressRestoreParams, body ReaderReadingProgressRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderReadingProgressRestoreResponse, error) {
	rsp, err := c.ReaderReadingProgressRestore(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderReadingProgressRestoreResponse(rsp)
}

// ShareGetManyWithResponse request returning *ShareGetManyResponse
func (c *ClientWithResponses) ShareGetManyWithResponse(ctx context.Context, params *ShareGetManyParams, reqEditors ...RequestEditorFn) (*ShareGetManyResponse, error) {
	rsp, err := c.ShareGetMany(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareGetManyResponse(rsp)
}

// ShareStoreWithBodyWithResponse request with arbitrary body returning *ShareStoreResponse
func (c *ClientWithResponses) ShareStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareStoreResponse, error) {
	rsp, err := c.ShareStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareStoreResponse(rsp)
}

func (c *ClientWithResponses) ShareStoreWithResponse(ctx context.Context, body ShareStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareStoreResponse, error) {
	rsp, err := c.ShareStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareStoreResponse(rsp)
}

// ShareDestroyWithResponse request returning *ShareDestroyResponse
func (c *ClientWithResponses) ShareDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ShareDestroyResponse, error) {
	rsp, err := c.ShareDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareDestroyResponse(rsp)
}

// ShareGetByIdWithResponse request returning *ShareGetByIdResponse
func (c *ClientWithResponses) ShareGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *ShareGetByIdParams, reqEditors ...RequestEditorFn) (*ShareGetByIdResponse, error) {
	rsp, err := c.ShareGetById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareGetByIdResponse(rsp)
}

// ShareUpdateWithBodyWithResponse request with arbitrary body returning *ShareUpdateResponse
func (c *ClientWithResponses) ShareUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareUpdateResponse, error) {
	rsp, err := c.ShareUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareUpdateResponse(rsp)
}

func (c *ClientWithResponses) ShareUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body ShareUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareUpdateResponse, error) {
	rsp, err := c.ShareUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareUpdateResponse(rsp)
}

// ShareBorrowWithBodyWithResponse request with arbitrary body returning *ShareBorrowResponse
func (c *ClientWithResponses) ShareBorrowWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareBorrowResponse, error) {
	rsp, err := c.ShareBorrowWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareBorrowResponse(rsp)
}

func (c *ClientWithResponses) ShareBorrowWithResponse(ctx context.Context, id openapi_types.UUID, body ShareBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareBorrowResponse, error) {
	rsp, err := c.ShareBorrow(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareBorrowResponse(rsp)
}

// ShareKillWithResponse request returning *ShareKillResponse
func (c *ClientWithResponses) ShareKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ShareKillResponse, error) {
	rsp, err := c.ShareKill(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareKillResponse(rsp)
}

// ShareCreateReportWithBodyWithResponse request with arbitrary body returning *ShareCreateReportResponse
func (c *ClientWithResponses) ShareCreateReportWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareCreateReportResponse, error) {
	rsp, err := c.ShareCreateReportWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareCreateReportResponse(rsp)
}

func (c *ClientWithResponses) ShareCreateReportWithResponse(ctx context.Context, id openapi_types.UUID, body ShareCreateReportJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareCreateReportResponse, error) {
	rsp, err := c.ShareCreateReport(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareCreateReportResponse(rsp)
}

// ShareRestoreWithBodyWithResponse request with arbitrary body returning *ShareRestoreResponse
func (c *ClientWithResponses) ShareRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ShareRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareRestoreResponse, error) {
	rsp, err := c.ShareRestoreWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareRestoreResponse(rsp)
}

func (c *ClientWithResponses) ShareRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *ShareRestoreParams, body ShareRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareRestoreResponse, error) {
	rsp, err := c.ShareRestore(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareRestoreResponse(rsp)
}

// ShareUpsertReviewWithBodyWithResponse request with arbitrary body returning *ShareUpsertReviewResponse
func (c *ClientWithResponses) ShareUpsertReviewWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareUpsertReviewResponse, error) {
	rsp, err := c.ShareUpsertReviewWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareUpsertReviewResponse(rsp)
}

func (c *ClientWithResponses) ShareUpsertReviewWithResponse(ctx context.Context, id openapi_types.UUID, body ShareUpsertReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareUpsertReviewResponse, error) {
	rsp, err := c.ShareUpsertReview(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareUpsertReviewResponse(rsp)
}

// SyncListEventsWithResponse request returning *SyncListEventsResponse
func (c *ClientWithResponses) SyncListEventsWithResponse(ctx context.Context, params *SyncListEventsParams, reqEditors ...RequestEditorFn) (*SyncListEventsResponse, error) {
	rsp, err := c.SyncListEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncListEventsResponse(rsp)
}

// SyncStoreEventWithBodyWithResponse request with arbitrary body returning *SyncStoreEventResponse
func (c *ClientWithResponses) SyncStoreEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncStoreEventResponse, error) {
	rsp, err := c.SyncStoreEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncStoreEventResponse(rsp)
}

func (c *ClientWithResponses) SyncStoreEventWithResponse(ctx context.Context, body SyncStoreEventJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncStoreEventResponse, error) {
	rsp, err := c.SyncStoreEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncStoreEventResponse(rsp)
}

// UserGetManyWithResponse request returning *UserGetManyResponse
func (c *ClientWithResponses) UserGetManyWithResponse(ctx context.Context, params *UserGetManyParams, reqEditors ...RequestEditorFn) (*UserGetManyResponse, error) {
	rsp, err := c.UserGetMany(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserGetManyResponse(rsp)
}

// UserStoreWithBodyWithResponse request with arbitrary body returning *UserStoreResponse
func (c *ClientWithResponses) UserStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserStoreResponse, error) {
	rsp, err := c.UserStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserStoreResponse(rsp)
}

func (c *ClientWithResponses) UserStoreWithResponse(ctx context.Context, body UserStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*UserStoreResponse, error) {
	rsp, err := c.UserStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserStoreResponse(rsp)
}

// ReaderGetUserPreferencesWithResponse request returning *ReaderGetUserPreferencesResponse
func (c *ClientWithResponses) ReaderGetUserPreferencesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReaderGetUserPreferencesResponse, error) {
	rsp, err := c.ReaderGetUserPreferences(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderGetUserPreferencesResponse(rsp)
}

// ReaderPatchUserPreferencesWithBodyWithResponse request with arbitrary body returning *ReaderPatchUserPreferencesResponse
func (c *ClientWithResponses) ReaderPatchUserPreferencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderPatchUserPreferencesResponse, error) {
	rsp, err := c.ReaderPatchUserPreferencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderPatchUserPreferencesResponse(rsp)
}

func (c *ClientWithResponses) ReaderPatchUserPreferencesWithResponse(ctx context.Context, body ReaderPatchUserPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderPatchUserPreferencesResponse, error) {
	rsp, err := c.ReaderPatchUserPreferences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderPatchUserPreferencesResponse(rsp)
}

// ReaderGetUserReaderStateWithResponse request returning *ReaderGetUserReaderStateResponse
func (c *ClientWithResponses) ReaderGetUserReaderStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReaderGetUserReaderStateResponse, error) {
	rsp, err := c.ReaderGetUserReaderState(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderGetUserReaderStateResponse(rsp)
}

// ReaderPatchUserReaderStateWithBodyWithResponse request with arbitrary body returning *ReaderPatchUserReaderStateResponse
func (c *ClientWithResponses) ReaderPatchUserReaderStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReaderPatchUserReaderStateResponse, error) {
	rsp, err := c.ReaderPatchUserReaderStateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderPatchUserReaderStateResponse(rsp)
}

func (c *ClientWithResponses) ReaderPatchUserReaderStateWithResponse(ctx context.Context, body ReaderPatchUserReaderStateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReaderPatchUserReaderStateResponse, error) {
	rsp, err := c.ReaderPatchUserReaderState(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReaderPatchUserReaderStateResponse(rsp)
}

// UserDestroyWithResponse request returning *UserDestroyResponse
func (c *ClientWithResponses) UserDestroyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*UserDestroyResponse, error) {
	rsp, err := c.UserDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserDestroyResponse(rsp)
}

// UserGetByIdWithResponse request returning *UserGetByIdResponse
func (c *ClientWithResponses) UserGetByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *UserGetByIdParams, reqEditors ...RequestEditorFn) (*UserGetByIdResponse, error) {
	rsp, err := c.UserGetById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserGetByIdResponse(rsp)
}

// UserUpdateWithBodyWithResponse request with arbitrary body returning *UserUpdateResponse
func (c *ClientWithResponses) UserUpdateWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error) {
	rsp, err := c.UserUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateResponse(rsp)
}

func (c *ClientWithResponses) UserUpdateWithResponse(ctx context.Context, id openapi_types.UUID, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error) {
	rsp, err := c.UserUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateResponse(rsp)
}

// UserKillWithResponse request returning *UserKillResponse
func (c *ClientWithResponses) UserKillWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*UserKillResponse, error) {
	rsp, err := c.UserKill(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserKillResponse(rsp)
}

// UserRestoreWithBodyWithResponse request with arbitrary body returning *UserRestoreResponse
func (c *ClientWithResponses) UserRestoreWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UserRestoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserRestoreResponse, error) {
	rsp, err := c.UserRestoreWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserRestoreResponse(rsp)
}

func (c *ClientWithResponses) UserRestoreWithResponse(ctx context.Context, id openapi_types.UUID, params *UserRestoreParams, body UserRestoreJSONRequestBody, reqEditors ...RequestEditorFn) (*UserRestoreResponse, error) {
	rsp, err := c.UserRestore(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserRestoreResponse(rsp)
}

// HealthGetHealthWithResponse request returning *HealthGetHealthResponse
func (c *ClientWithResponses) HealthGetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthGetHealthResponse, error) {
	rsp, err := c.HealthGetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthGetHealthResponse(rsp)
}

// ParseReaderAnnotationsGetManyResponse parses an HTTP response from a ReaderAnnotationsGetManyWithResponse call
func ParseReaderAnnotationsGetManyResponse(rsp *http.Response) (*ReaderAnnotationsGetManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderAnnotationsGetManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				Color         *string            `json:"color,omitempty"`
				CreatedAt     time.Time          `json:"createdAt"`
				DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
				EbookId       openapi_types.UUID `json:"ebookId"`
				HighlightText *string            `json:"highlightText,omitempty"`
				Id            openapi_types.UUID `json:"id"`
				LocationEnd   string             `json:"locationEnd"`
				LocationStart string             `json:"locationStart"`
				Note          *string            `json:"note,omitempty"`
				RowVersion    int                `json:"rowVersion"`
				UpdatedAt     time.Time          `json:"updatedAt"`
				UserId        openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Limit      *float32                          `json:"limit,omitempty"`
			Message    *string                           `json:"message,omitempty"`
			Page       float32                           `json:"page"`
			Status     ReaderAnnotationsGetMany200Status `json:"status"`
			Success    *bool                             `json:"success,omitempty"`
			Total      *float32                          `json:"total,omitempty"`
			TotalPages *float32                          `json:"totalPages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsGetMany401Status  `json:"status"`
			Success ReaderAnnotationsGetMany401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsGetMany403Status  `json:"status"`
			Success ReaderAnnotationsGetMany403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsGetMany404Status  `json:"status"`
			Success ReaderAnnotationsGetMany404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsGetMany500Status  `json:"status"`
			Success ReaderAnnotationsGetMany500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderAnnotationsStoreResponse parses an HTTP response from a ReaderAnnotationsStoreWithResponse call
func ParseReaderAnnotationsStoreResponse(rsp *http.Response) (*ReaderAnnotationsStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderAnnotationsStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data struct {
				Color         *string            `json:"color,omitempty"`
				CreatedAt     time.Time          `json:"createdAt"`
				DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
				EbookId       openapi_types.UUID `json:"ebookId"`
				HighlightText *string            `json:"highlightText,omitempty"`
				Id            openapi_types.UUID `json:"id"`
				LocationEnd   string             `json:"locationEnd"`
				LocationStart string             `json:"locationStart"`
				Note          *string            `json:"note,omitempty"`
				RowVersion    int                `json:"rowVersion"`
				UpdatedAt     time.Time          `json:"updatedAt"`
				UserId        openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderAnnotationsStore401Status  `json:"status"`
			Success ReaderAnnotationsStore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderAnnotationsStore403Status  `json:"status"`
			Success ReaderAnnotationsStore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderAnnotationsStore404Status  `json:"status"`
			Success ReaderAnnotationsStore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderAnnotationsStore500Status  `json:"status"`
			Success ReaderAnnotationsStore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderAnnotationsDestroyResponse parses an HTTP response from a ReaderAnnotationsDestroyWithResponse call
func ParseReaderAnnotationsDestroyResponse(rsp *http.Response) (*ReaderAnnotationsDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderAnnotationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsDestroy401Status  `json:"status"`
			Success ReaderAnnotationsDestroy401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsDestroy403Status  `json:"status"`
			Success ReaderAnnotationsDestroy403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsDestroy404Status  `json:"status"`
			Success ReaderAnnotationsDestroy404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsDestroy500Status  `json:"status"`
			Success ReaderAnnotationsDestroy500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderAnnotationsGetByIdResponse parses an HTTP response from a ReaderAnnotationsGetByIdWithResponse call
func ParseReaderAnnotationsGetByIdResponse(rsp *http.Response) (*ReaderAnnotationsGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderAnnotationsGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Color         *string            `json:"color,omitempty"`
				CreatedAt     time.Time          `json:"createdAt"`
				DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
				EbookId       openapi_types.UUID `json:"ebookId"`
				HighlightText *string            `json:"highlightText,omitempty"`
				Id            openapi_types.UUID `json:"id"`
				LocationEnd   string             `json:"locationEnd"`
				LocationStart string             `json:"locationStart"`
				Note          *string            `json:"note,omitempty"`
				RowVersion    int                `json:"rowVersion"`
				UpdatedAt     time.Time          `json:"updatedAt"`
				UserId        openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsGetById401Status  `json:"status"`
			Success ReaderAnnotationsGetById401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsGetById403Status  `json:"status"`
			Success ReaderAnnotationsGetById403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsGetById404Status  `json:"status"`
			Success ReaderAnnotationsGetById404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsGetById500Status  `json:"status"`
			Success ReaderAnnotationsGetById500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderAnnotationsUpdateResponse parses an HTTP response from a ReaderAnnotationsUpdateWithResponse call
func ParseReaderAnnotationsUpdateResponse(rsp *http.Response) (*ReaderAnnotationsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderAnnotationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Color         *string            `json:"color,omitempty"`
				CreatedAt     time.Time          `json:"createdAt"`
				DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
				EbookId       openapi_types.UUID `json:"ebookId"`
				HighlightText *string            `json:"highlightText,omitempty"`
				Id            openapi_types.UUID `json:"id"`
				LocationEnd   string             `json:"locationEnd"`
				LocationStart string             `json:"locationStart"`
				Note          *string            `json:"note,omitempty"`
				RowVersion    int                `json:"rowVersion"`
				UpdatedAt     time.Time          `json:"updatedAt"`
				UserId        openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                           `json:"message,omitempty"`
			Status  ReaderAnnotationsUpdate401Status  `json:"status"`
			Success ReaderAnnotationsUpdate401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                           `json:"message,omitempty"`
			Status  ReaderAnnotationsUpdate403Status  `json:"status"`
			Success ReaderAnnotationsUpdate403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                           `json:"message,omitempty"`
			Status  ReaderAnnotationsUpdate404Status  `json:"status"`
			Success ReaderAnnotationsUpdate404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                           `json:"message,omitempty"`
			Status  ReaderAnnotationsUpdate500Status  `json:"status"`
			Success ReaderAnnotationsUpdate500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderAnnotationsKillResponse parses an HTTP response from a ReaderAnnotationsKillWithResponse call
func ParseReaderAnnotationsKillResponse(rsp *http.Response) (*ReaderAnnotationsKillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderAnnotationsKillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  ReaderAnnotationsKill401Status  `json:"status"`
			Success ReaderAnnotationsKill401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  ReaderAnnotationsKill403Status  `json:"status"`
			Success ReaderAnnotationsKill403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  ReaderAnnotationsKill404Status  `json:"status"`
			Success ReaderAnnotationsKill404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  ReaderAnnotationsKill500Status  `json:"status"`
			Success ReaderAnnotationsKill500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderAnnotationsRestoreResponse parses an HTTP response from a ReaderAnnotationsRestoreWithResponse call
func ParseReaderAnnotationsRestoreResponse(rsp *http.Response) (*ReaderAnnotationsRestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderAnnotationsRestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Color         *string            `json:"color,omitempty"`
				CreatedAt     time.Time          `json:"createdAt"`
				DeletedAt     *time.Time         `json:"deletedAt,omitempty"`
				EbookId       openapi_types.UUID `json:"ebookId"`
				HighlightText *string            `json:"highlightText,omitempty"`
				Id            openapi_types.UUID `json:"id"`
				LocationEnd   string             `json:"locationEnd"`
				LocationStart string             `json:"locationStart"`
				Note          *string            `json:"note,omitempty"`
				RowVersion    int                `json:"rowVersion"`
				UpdatedAt     time.Time          `json:"updatedAt"`
				UserId        openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsRestore401Status  `json:"status"`
			Success ReaderAnnotationsRestore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsRestore403Status  `json:"status"`
			Success ReaderAnnotationsRestore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsRestore404Status  `json:"status"`
			Success ReaderAnnotationsRestore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderAnnotationsRestore500Status  `json:"status"`
			Success ReaderAnnotationsRestore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthGoogleLoginResponse parses an HTTP response from a AuthGoogleLoginWithResponse call
func ParseAuthGoogleLoginResponse(rsp *http.Response) (*AuthGoogleLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthGoogleLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 302:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON302 = &dest

	}

	return response, nil
}

// ParseAuthGoogleCallbackResponse parses an HTTP response from a AuthGoogleCallbackWithResponse call
func ParseAuthGoogleCallbackResponse(rsp *http.Response) (*AuthGoogleCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthGoogleCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 302:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON302 = &dest

	}

	return response, nil
}

// ParseAuthGoogleDevicePollResponse parses an HTTP response from a AuthGoogleDevicePollWithResponse call
func ParseAuthGoogleDevicePollResponse(rsp *http.Response) (*AuthGoogleDevicePollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthGoogleDevicePollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *struct {
				RefreshToken struct {
					ExpiresAt time.Time `json:"expiresAt"`
					Token     string    `json:"token"`
				} `json:"refreshToken"`
				Token struct {
					ExpiresAt time.Time `json:"expiresAt"`
					Token     string    `json:"token"`
				} `json:"token"`
				User struct {
					CreatedAt       time.Time           `json:"createdAt"`
					DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
					Email           openapi_types.Email `json:"email"`
					EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
					GoogleId        *string             `json:"googleId,omitempty"`
					Id              openapi_types.UUID  `json:"id"`
					IsAdmin         *bool               `json:"isAdmin,omitempty"`
					LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
					UpdatedAt       time.Time           `json:"updatedAt"`
					Username        string              `json:"username"`
				} `json:"user"`
			} `json:"result,omitempty"`
			Status AuthGoogleDevicePoll200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                        `json:"message,omitempty"`
			Status  AuthGoogleDevicePoll401Status  `json:"status"`
			Success AuthGoogleDevicePoll401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                        `json:"message,omitempty"`
			Status  AuthGoogleDevicePoll403Status  `json:"status"`
			Success AuthGoogleDevicePoll403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                        `json:"message,omitempty"`
			Status  AuthGoogleDevicePoll404Status  `json:"status"`
			Success AuthGoogleDevicePoll404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                        `json:"message,omitempty"`
			Status  AuthGoogleDevicePoll500Status  `json:"status"`
			Success AuthGoogleDevicePoll500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthGoogleDeviceStartResponse parses an HTTP response from a AuthGoogleDeviceStartWithResponse call
func ParseAuthGoogleDeviceStartResponse(rsp *http.Response) (*AuthGoogleDeviceStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthGoogleDeviceStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AuthUrl         string    `json:"authUrl"`
			DeviceCode      string    `json:"deviceCode"`
			ExpiresAt       time.Time `json:"expiresAt"`
			IntervalSeconds int       `json:"intervalSeconds"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  AuthGoogleDeviceStart401Status  `json:"status"`
			Success AuthGoogleDeviceStart401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  AuthGoogleDeviceStart403Status  `json:"status"`
			Success AuthGoogleDeviceStart403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  AuthGoogleDeviceStart404Status  `json:"status"`
			Success AuthGoogleDeviceStart404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  AuthGoogleDeviceStart500Status  `json:"status"`
			Success AuthGoogleDeviceStart500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthLoginResponse parses an HTTP response from a AuthLoginWithResponse call
func ParseAuthLoginResponse(rsp *http.Response) (*AuthLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  AuthLogin401Status  `json:"status"`
			Success AuthLogin401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  AuthLogin403Status  `json:"status"`
			Success AuthLogin403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  AuthLogin404Status  `json:"status"`
			Success AuthLogin404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  AuthLogin500Status  `json:"status"`
			Success AuthLogin500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthLogoutResponse parses an HTTP response from a AuthLogoutWithResponse call
func ParseAuthLogoutResponse(rsp *http.Response) (*AuthLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  AuthLogout401Status  `json:"status"`
			Success AuthLogout401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  AuthLogout403Status  `json:"status"`
			Success AuthLogout403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  AuthLogout404Status  `json:"status"`
			Success AuthLogout404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  AuthLogout500Status  `json:"status"`
			Success AuthLogout500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthLogoutAllResponse parses an HTTP response from a AuthLogoutAllWithResponse call
func ParseAuthLogoutAllResponse(rsp *http.Response) (*AuthLogoutAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLogoutAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                 `json:"message,omitempty"`
			Status  AuthLogoutAll401Status  `json:"status"`
			Success AuthLogoutAll401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                 `json:"message,omitempty"`
			Status  AuthLogoutAll403Status  `json:"status"`
			Success AuthLogoutAll403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                 `json:"message,omitempty"`
			Status  AuthLogoutAll404Status  `json:"status"`
			Success AuthLogoutAll404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                 `json:"message,omitempty"`
			Status  AuthLogoutAll500Status  `json:"status"`
			Success AuthLogoutAll500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthMeResponse parses an HTTP response from a AuthMeWithResponse call
func ParseAuthMeResponse(rsp *http.Response) (*AuthMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string          `json:"message,omitempty"`
			Status  AuthMe401Status  `json:"status"`
			Success AuthMe401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string          `json:"message,omitempty"`
			Status  AuthMe403Status  `json:"status"`
			Success AuthMe403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string          `json:"message,omitempty"`
			Status  AuthMe404Status  `json:"status"`
			Success AuthMe404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string          `json:"message,omitempty"`
			Status  AuthMe500Status  `json:"status"`
			Success AuthMe500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthRefreshResponse parses an HTTP response from a AuthRefreshWithResponse call
func ParseAuthRefreshResponse(rsp *http.Response) (*AuthRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  AuthRefresh401Status  `json:"status"`
			Success AuthRefresh401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  AuthRefresh403Status  `json:"status"`
			Success AuthRefresh403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  AuthRefresh404Status  `json:"status"`
			Success AuthRefresh404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  AuthRefresh500Status  `json:"status"`
			Success AuthRefresh500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthRegisterResponse parses an HTTP response from a AuthRegisterWithResponse call
func ParseAuthRegisterResponse(rsp *http.Response) (*AuthRegisterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthRegisterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  AuthRegister401Status  `json:"status"`
			Success AuthRegister401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  AuthRegister403Status  `json:"status"`
			Success AuthRegister403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  AuthRegister404Status  `json:"status"`
			Success AuthRegister404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  AuthRegister500Status  `json:"status"`
			Success AuthRegister500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthResendVerificationResponse parses an HTTP response from a AuthResendVerificationWithResponse call
func ParseAuthResendVerificationResponse(rsp *http.Response) (*AuthResendVerificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthResendVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  AuthResendVerification401Status  `json:"status"`
			Success AuthResendVerification401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  AuthResendVerification403Status  `json:"status"`
			Success AuthResendVerification403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  AuthResendVerification404Status  `json:"status"`
			Success AuthResendVerification404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  AuthResendVerification500Status  `json:"status"`
			Success AuthResendVerification500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthVerifyEmailResponse parses an HTTP response from a AuthVerifyEmailWithResponse call
func ParseAuthVerifyEmailResponse(rsp *http.Response) (*AuthVerifyEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthVerifyEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreatedAt       time.Time           `json:"createdAt"`
			DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
			Email           openapi_types.Email `json:"email"`
			EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
			GoogleId        *string             `json:"googleId,omitempty"`
			Id              openapi_types.UUID  `json:"id"`
			IsAdmin         *bool               `json:"isAdmin,omitempty"`
			LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
			UpdatedAt       time.Time           `json:"updatedAt"`
			Username        string              `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                   `json:"message,omitempty"`
			Status  AuthVerifyEmail401Status  `json:"status"`
			Success AuthVerifyEmail401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                   `json:"message,omitempty"`
			Status  AuthVerifyEmail403Status  `json:"status"`
			Success AuthVerifyEmail403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                   `json:"message,omitempty"`
			Status  AuthVerifyEmail404Status  `json:"status"`
			Success AuthVerifyEmail404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                   `json:"message,omitempty"`
			Status  AuthVerifyEmail500Status  `json:"status"`
			Success AuthVerifyEmail500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderBookmarksGetManyResponse parses an HTTP response from a ReaderBookmarksGetManyWithResponse call
func ParseReaderBookmarksGetManyResponse(rsp *http.Response) (*ReaderBookmarksGetManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderBookmarksGetManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				CreatedAt  time.Time          `json:"createdAt"`
				DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
				EbookId    openapi_types.UUID `json:"ebookId"`
				Id         openapi_types.UUID `json:"id"`
				Label      *string            `json:"label,omitempty"`
				Location   string             `json:"location"`
				RowVersion int                `json:"rowVersion"`
				UpdatedAt  time.Time          `json:"updatedAt"`
				UserId     openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Limit      *float32                        `json:"limit,omitempty"`
			Message    *string                         `json:"message,omitempty"`
			Page       float32                         `json:"page"`
			Status     ReaderBookmarksGetMany200Status `json:"status"`
			Success    *bool                           `json:"success,omitempty"`
			Total      *float32                        `json:"total,omitempty"`
			TotalPages *float32                        `json:"totalPages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksGetMany401Status  `json:"status"`
			Success ReaderBookmarksGetMany401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksGetMany403Status  `json:"status"`
			Success ReaderBookmarksGetMany403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksGetMany404Status  `json:"status"`
			Success ReaderBookmarksGetMany404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksGetMany500Status  `json:"status"`
			Success ReaderBookmarksGetMany500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderBookmarksStoreResponse parses an HTTP response from a ReaderBookmarksStoreWithResponse call
func ParseReaderBookmarksStoreResponse(rsp *http.Response) (*ReaderBookmarksStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderBookmarksStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data struct {
				CreatedAt  time.Time          `json:"createdAt"`
				DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
				EbookId    openapi_types.UUID `json:"ebookId"`
				Id         openapi_types.UUID `json:"id"`
				Label      *string            `json:"label,omitempty"`
				Location   string             `json:"location"`
				RowVersion int                `json:"rowVersion"`
				UpdatedAt  time.Time          `json:"updatedAt"`
				UserId     openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                        `json:"message,omitempty"`
			Status  ReaderBookmarksStore401Status  `json:"status"`
			Success ReaderBookmarksStore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                        `json:"message,omitempty"`
			Status  ReaderBookmarksStore403Status  `json:"status"`
			Success ReaderBookmarksStore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                        `json:"message,omitempty"`
			Status  ReaderBookmarksStore404Status  `json:"status"`
			Success ReaderBookmarksStore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                        `json:"message,omitempty"`
			Status  ReaderBookmarksStore500Status  `json:"status"`
			Success ReaderBookmarksStore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderBookmarksDestroyResponse parses an HTTP response from a ReaderBookmarksDestroyWithResponse call
func ParseReaderBookmarksDestroyResponse(rsp *http.Response) (*ReaderBookmarksDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderBookmarksDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksDestroy401Status  `json:"status"`
			Success ReaderBookmarksDestroy401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksDestroy403Status  `json:"status"`
			Success ReaderBookmarksDestroy403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksDestroy404Status  `json:"status"`
			Success ReaderBookmarksDestroy404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksDestroy500Status  `json:"status"`
			Success ReaderBookmarksDestroy500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderBookmarksGetByIdResponse parses an HTTP response from a ReaderBookmarksGetByIdWithResponse call
func ParseReaderBookmarksGetByIdResponse(rsp *http.Response) (*ReaderBookmarksGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderBookmarksGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt  time.Time          `json:"createdAt"`
				DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
				EbookId    openapi_types.UUID `json:"ebookId"`
				Id         openapi_types.UUID `json:"id"`
				Label      *string            `json:"label,omitempty"`
				Location   string             `json:"location"`
				RowVersion int                `json:"rowVersion"`
				UpdatedAt  time.Time          `json:"updatedAt"`
				UserId     openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksGetById401Status  `json:"status"`
			Success ReaderBookmarksGetById401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksGetById403Status  `json:"status"`
			Success ReaderBookmarksGetById403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksGetById404Status  `json:"status"`
			Success ReaderBookmarksGetById404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksGetById500Status  `json:"status"`
			Success ReaderBookmarksGetById500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderBookmarksUpdateResponse parses an HTTP response from a ReaderBookmarksUpdateWithResponse call
func ParseReaderBookmarksUpdateResponse(rsp *http.Response) (*ReaderBookmarksUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderBookmarksUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt  time.Time          `json:"createdAt"`
				DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
				EbookId    openapi_types.UUID `json:"ebookId"`
				Id         openapi_types.UUID `json:"id"`
				Label      *string            `json:"label,omitempty"`
				Location   string             `json:"location"`
				RowVersion int                `json:"rowVersion"`
				UpdatedAt  time.Time          `json:"updatedAt"`
				UserId     openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  ReaderBookmarksUpdate401Status  `json:"status"`
			Success ReaderBookmarksUpdate401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  ReaderBookmarksUpdate403Status  `json:"status"`
			Success ReaderBookmarksUpdate403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  ReaderBookmarksUpdate404Status  `json:"status"`
			Success ReaderBookmarksUpdate404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                         `json:"message,omitempty"`
			Status  ReaderBookmarksUpdate500Status  `json:"status"`
			Success ReaderBookmarksUpdate500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderBookmarksKillResponse parses an HTTP response from a ReaderBookmarksKillWithResponse call
func ParseReaderBookmarksKillResponse(rsp *http.Response) (*ReaderBookmarksKillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderBookmarksKillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  ReaderBookmarksKill401Status  `json:"status"`
			Success ReaderBookmarksKill401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  ReaderBookmarksKill403Status  `json:"status"`
			Success ReaderBookmarksKill403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  ReaderBookmarksKill404Status  `json:"status"`
			Success ReaderBookmarksKill404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  ReaderBookmarksKill500Status  `json:"status"`
			Success ReaderBookmarksKill500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderBookmarksRestoreResponse parses an HTTP response from a ReaderBookmarksRestoreWithResponse call
func ParseReaderBookmarksRestoreResponse(rsp *http.Response) (*ReaderBookmarksRestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderBookmarksRestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt  time.Time          `json:"createdAt"`
				DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
				EbookId    openapi_types.UUID `json:"ebookId"`
				Id         openapi_types.UUID `json:"id"`
				Label      *string            `json:"label,omitempty"`
				Location   string             `json:"location"`
				RowVersion int                `json:"rowVersion"`
				UpdatedAt  time.Time          `json:"updatedAt"`
				UserId     openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksRestore401Status  `json:"status"`
			Success ReaderBookmarksRestore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksRestore403Status  `json:"status"`
			Success ReaderBookmarksRestore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksRestore404Status  `json:"status"`
			Success ReaderBookmarksRestore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                          `json:"message,omitempty"`
			Status  ReaderBookmarksRestore500Status  `json:"status"`
			Success ReaderBookmarksRestore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareReturnBorrowResponse parses an HTTP response from a ShareReturnBorrowWithResponse call
func ParseShareReturnBorrowResponse(rsp *http.Response) (*ShareReturnBorrowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareReturnBorrowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				BorrowerUserId      openapi_types.UUID             `json:"borrowerUserId"`
				CreatedAt           time.Time                      `json:"createdAt"`
				DueAt               time.Time                      `json:"dueAt"`
				ExpiredAt           *time.Time                     `json:"expiredAt,omitempty"`
				Id                  openapi_types.UUID             `json:"id"`
				LegalAcknowledgedAt time.Time                      `json:"legalAcknowledgedAt"`
				ReturnedAt          *time.Time                     `json:"returnedAt,omitempty"`
				ShareId             openapi_types.UUID             `json:"shareId"`
				StartedAt           time.Time                      `json:"startedAt"`
				Status              ShareReturnBorrow200DataStatus `json:"status"`
				UpdatedAt           time.Time                      `json:"updatedAt"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareReturnBorrow401Status  `json:"status"`
			Success ShareReturnBorrow401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareReturnBorrow403Status  `json:"status"`
			Success ShareReturnBorrow403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareReturnBorrow404Status  `json:"status"`
			Success ShareReturnBorrow404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareReturnBorrow500Status  `json:"status"`
			Success ShareReturnBorrow500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEbookGetManyResponse parses an HTTP response from a EbookGetManyWithResponse call
func ParseEbookGetManyResponse(rsp *http.Response) (*EbookGetManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EbookGetManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				ChecksumSha256 string                    `json:"checksumSha256"`
				CreatedAt      time.Time                 `json:"createdAt"`
				DeletedAt      *time.Time                `json:"deletedAt,omitempty"`
				Description    *string                   `json:"description,omitempty"`
				FileSizeBytes  int                       `json:"fileSizeBytes"`
				Format         EbookGetMany200DataFormat `json:"format"`
				Id             openapi_types.UUID        `json:"id"`
				ImportedAt     time.Time                 `json:"importedAt"`
				LanguageCode   *string                   `json:"languageCode,omitempty"`
				OwnerUserId    openapi_types.UUID        `json:"ownerUserId"`
				StorageKey     string                    `json:"storageKey"`
				Title          string                    `json:"title"`
				UpdatedAt      time.Time                 `json:"updatedAt"`
			} `json:"data"`
			Limit      *float32              `json:"limit,omitempty"`
			Message    *string               `json:"message,omitempty"`
			Page       float32               `json:"page"`
			Status     EbookGetMany200Status `json:"status"`
			Success    *bool                 `json:"success,omitempty"`
			Total      *float32              `json:"total,omitempty"`
			TotalPages *float32              `json:"totalPages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookGetMany401Status  `json:"status"`
			Success EbookGetMany401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookGetMany403Status  `json:"status"`
			Success EbookGetMany403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookGetMany404Status  `json:"status"`
			Success EbookGetMany404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookGetMany500Status  `json:"status"`
			Success EbookGetMany500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEbookStoreResponse parses an HTTP response from a EbookStoreWithResponse call
func ParseEbookStoreResponse(rsp *http.Response) (*EbookStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EbookStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data struct {
				ChecksumSha256 string                  `json:"checksumSha256"`
				CreatedAt      time.Time               `json:"createdAt"`
				DeletedAt      *time.Time              `json:"deletedAt,omitempty"`
				Description    *string                 `json:"description,omitempty"`
				FileSizeBytes  int                     `json:"fileSizeBytes"`
				Format         EbookStore201DataFormat `json:"format"`
				Id             openapi_types.UUID      `json:"id"`
				ImportedAt     time.Time               `json:"importedAt"`
				LanguageCode   *string                 `json:"languageCode,omitempty"`
				OwnerUserId    openapi_types.UUID      `json:"ownerUserId"`
				StorageKey     string                  `json:"storageKey"`
				Title          string                  `json:"title"`
				UpdatedAt      time.Time               `json:"updatedAt"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  EbookStore401Status  `json:"status"`
			Success EbookStore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  EbookStore403Status  `json:"status"`
			Success EbookStore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  EbookStore404Status  `json:"status"`
			Success EbookStore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  EbookStore500Status  `json:"status"`
			Success EbookStore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEbookDestroyResponse parses an HTTP response from a EbookDestroyWithResponse call
func ParseEbookDestroyResponse(rsp *http.Response) (*EbookDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EbookDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookDestroy401Status  `json:"status"`
			Success EbookDestroy401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookDestroy403Status  `json:"status"`
			Success EbookDestroy403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookDestroy404Status  `json:"status"`
			Success EbookDestroy404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookDestroy500Status  `json:"status"`
			Success EbookDestroy500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEbookGetByIdResponse parses an HTTP response from a EbookGetByIdWithResponse call
func ParseEbookGetByIdResponse(rsp *http.Response) (*EbookGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EbookGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				ChecksumSha256 string                    `json:"checksumSha256"`
				CreatedAt      time.Time                 `json:"createdAt"`
				DeletedAt      *time.Time                `json:"deletedAt,omitempty"`
				Description    *string                   `json:"description,omitempty"`
				FileSizeBytes  int                       `json:"fileSizeBytes"`
				Format         EbookGetById200DataFormat `json:"format"`
				Id             openapi_types.UUID        `json:"id"`
				ImportedAt     time.Time                 `json:"importedAt"`
				LanguageCode   *string                   `json:"languageCode,omitempty"`
				OwnerUserId    openapi_types.UUID        `json:"ownerUserId"`
				StorageKey     string                    `json:"storageKey"`
				Title          string                    `json:"title"`
				UpdatedAt      time.Time                 `json:"updatedAt"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookGetById401Status  `json:"status"`
			Success EbookGetById401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookGetById403Status  `json:"status"`
			Success EbookGetById403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookGetById404Status  `json:"status"`
			Success EbookGetById404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookGetById500Status  `json:"status"`
			Success EbookGetById500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEbookUpdateResponse parses an HTTP response from a EbookUpdateWithResponse call
func ParseEbookUpdateResponse(rsp *http.Response) (*EbookUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EbookUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				ChecksumSha256 string                   `json:"checksumSha256"`
				CreatedAt      time.Time                `json:"createdAt"`
				DeletedAt      *time.Time               `json:"deletedAt,omitempty"`
				Description    *string                  `json:"description,omitempty"`
				FileSizeBytes  int                      `json:"fileSizeBytes"`
				Format         EbookUpdate200DataFormat `json:"format"`
				Id             openapi_types.UUID       `json:"id"`
				ImportedAt     time.Time                `json:"importedAt"`
				LanguageCode   *string                  `json:"languageCode,omitempty"`
				OwnerUserId    openapi_types.UUID       `json:"ownerUserId"`
				StorageKey     string                   `json:"storageKey"`
				Title          string                   `json:"title"`
				UpdatedAt      time.Time                `json:"updatedAt"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  EbookUpdate401Status  `json:"status"`
			Success EbookUpdate401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  EbookUpdate403Status  `json:"status"`
			Success EbookUpdate403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  EbookUpdate404Status  `json:"status"`
			Success EbookUpdate404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  EbookUpdate500Status  `json:"status"`
			Success EbookUpdate500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEbookKillResponse parses an HTTP response from a EbookKillWithResponse call
func ParseEbookKillResponse(rsp *http.Response) (*EbookKillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EbookKillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  EbookKill401Status  `json:"status"`
			Success EbookKill401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  EbookKill403Status  `json:"status"`
			Success EbookKill403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  EbookKill404Status  `json:"status"`
			Success EbookKill404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  EbookKill500Status  `json:"status"`
			Success EbookKill500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEbookRemoveMetadataResponse parses an HTTP response from a EbookRemoveMetadataWithResponse call
func ParseEbookRemoveMetadataResponse(rsp *http.Response) (*EbookRemoveMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EbookRemoveMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  EbookRemoveMetadata401Status  `json:"status"`
			Success EbookRemoveMetadata401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  EbookRemoveMetadata403Status  `json:"status"`
			Success EbookRemoveMetadata403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  EbookRemoveMetadata404Status  `json:"status"`
			Success EbookRemoveMetadata404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  EbookRemoveMetadata500Status  `json:"status"`
			Success EbookRemoveMetadata500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEbookAttachMetadataResponse parses an HTTP response from a EbookAttachMetadataWithResponse call
func ParseEbookAttachMetadataResponse(rsp *http.Response) (*EbookAttachMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EbookAttachMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				AttachedAt    time.Time                `json:"attachedAt"`
				Categories    *[]string                `json:"categories,omitempty"`
				DeletedAt     *time.Time               `json:"deletedAt,omitempty"`
				EbookId       openapi_types.UUID       `json:"ebookId"`
				GoogleBooksId string                   `json:"googleBooksId"`
				InfoLink      *string                  `json:"infoLink,omitempty"`
				Isbn10        *string                  `json:"isbn10,omitempty"`
				Isbn13        *string                  `json:"isbn13,omitempty"`
				PageCount     *int                     `json:"pageCount,omitempty"`
				PublishedDate *string                  `json:"publishedDate,omitempty"`
				Publisher     *string                  `json:"publisher,omitempty"`
				RawPayload    *map[string]*interface{} `json:"rawPayload,omitempty"`
				ThumbnailUrl  *string                  `json:"thumbnailUrl,omitempty"`
				UpdatedAt     time.Time                `json:"updatedAt"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  EbookAttachMetadata401Status  `json:"status"`
			Success EbookAttachMetadata401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  EbookAttachMetadata403Status  `json:"status"`
			Success EbookAttachMetadata403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  EbookAttachMetadata404Status  `json:"status"`
			Success EbookAttachMetadata404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                       `json:"message,omitempty"`
			Status  EbookAttachMetadata500Status  `json:"status"`
			Success EbookAttachMetadata500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEbookRestoreResponse parses an HTTP response from a EbookRestoreWithResponse call
func ParseEbookRestoreResponse(rsp *http.Response) (*EbookRestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EbookRestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				ChecksumSha256 string                    `json:"checksumSha256"`
				CreatedAt      time.Time                 `json:"createdAt"`
				DeletedAt      *time.Time                `json:"deletedAt,omitempty"`
				Description    *string                   `json:"description,omitempty"`
				FileSizeBytes  int                       `json:"fileSizeBytes"`
				Format         EbookRestore200DataFormat `json:"format"`
				Id             openapi_types.UUID        `json:"id"`
				ImportedAt     time.Time                 `json:"importedAt"`
				LanguageCode   *string                   `json:"languageCode,omitempty"`
				OwnerUserId    openapi_types.UUID        `json:"ownerUserId"`
				StorageKey     string                    `json:"storageKey"`
				Title          string                    `json:"title"`
				UpdatedAt      time.Time                 `json:"updatedAt"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookRestore401Status  `json:"status"`
			Success EbookRestore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookRestore403Status  `json:"status"`
			Success EbookRestore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookRestore404Status  `json:"status"`
			Success EbookRestore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  EbookRestore500Status  `json:"status"`
			Success EbookRestore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderReadingProgressGetManyResponse parses an HTTP response from a ReaderReadingProgressGetManyWithResponse call
func ParseReaderReadingProgressGetManyResponse(rsp *http.Response) (*ReaderReadingProgressGetManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderReadingProgressGetManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				CreatedAt       time.Time                                      `json:"createdAt"`
				DeletedAt       *time.Time                                     `json:"deletedAt,omitempty"`
				EbookId         openapi_types.UUID                             `json:"ebookId"`
				Id              openapi_types.UUID                             `json:"id"`
				LastReadAt      *time.Time                                     `json:"lastReadAt,omitempty"`
				Location        string                                         `json:"location"`
				ProgressPercent *float32                                       `json:"progressPercent,omitempty"`
				ReadingMode     ReaderReadingProgressGetMany200DataReadingMode `json:"readingMode"`
				RowVersion      int                                            `json:"rowVersion"`
				UpdatedAt       time.Time                                      `json:"updatedAt"`
				UserId          openapi_types.UUID                             `json:"userId"`
			} `json:"data"`
			Limit      *float32                              `json:"limit,omitempty"`
			Message    *string                               `json:"message,omitempty"`
			Page       float32                               `json:"page"`
			Status     ReaderReadingProgressGetMany200Status `json:"status"`
			Success    *bool                                 `json:"success,omitempty"`
			Total      *float32                              `json:"total,omitempty"`
			TotalPages *float32                              `json:"totalPages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressGetMany401Status  `json:"status"`
			Success ReaderReadingProgressGetMany401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressGetMany403Status  `json:"status"`
			Success ReaderReadingProgressGetMany403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressGetMany404Status  `json:"status"`
			Success ReaderReadingProgressGetMany404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressGetMany500Status  `json:"status"`
			Success ReaderReadingProgressGetMany500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderReadingProgressStoreResponse parses an HTTP response from a ReaderReadingProgressStoreWithResponse call
func ParseReaderReadingProgressStoreResponse(rsp *http.Response) (*ReaderReadingProgressStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderReadingProgressStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data struct {
				CreatedAt       time.Time                                    `json:"createdAt"`
				DeletedAt       *time.Time                                   `json:"deletedAt,omitempty"`
				EbookId         openapi_types.UUID                           `json:"ebookId"`
				Id              openapi_types.UUID                           `json:"id"`
				LastReadAt      *time.Time                                   `json:"lastReadAt,omitempty"`
				Location        string                                       `json:"location"`
				ProgressPercent *float32                                     `json:"progressPercent,omitempty"`
				ReadingMode     ReaderReadingProgressStore201DataReadingMode `json:"readingMode"`
				RowVersion      int                                          `json:"rowVersion"`
				UpdatedAt       time.Time                                    `json:"updatedAt"`
				UserId          openapi_types.UUID                           `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderReadingProgressStore401Status  `json:"status"`
			Success ReaderReadingProgressStore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderReadingProgressStore403Status  `json:"status"`
			Success ReaderReadingProgressStore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderReadingProgressStore404Status  `json:"status"`
			Success ReaderReadingProgressStore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderReadingProgressStore500Status  `json:"status"`
			Success ReaderReadingProgressStore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderReadingProgressDestroyResponse parses an HTTP response from a ReaderReadingProgressDestroyWithResponse call
func ParseReaderReadingProgressDestroyResponse(rsp *http.Response) (*ReaderReadingProgressDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderReadingProgressDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressDestroy401Status  `json:"status"`
			Success ReaderReadingProgressDestroy401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressDestroy403Status  `json:"status"`
			Success ReaderReadingProgressDestroy403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressDestroy404Status  `json:"status"`
			Success ReaderReadingProgressDestroy404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressDestroy500Status  `json:"status"`
			Success ReaderReadingProgressDestroy500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderReadingProgressGetByIdResponse parses an HTTP response from a ReaderReadingProgressGetByIdWithResponse call
func ParseReaderReadingProgressGetByIdResponse(rsp *http.Response) (*ReaderReadingProgressGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderReadingProgressGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt       time.Time                                      `json:"createdAt"`
				DeletedAt       *time.Time                                     `json:"deletedAt,omitempty"`
				EbookId         openapi_types.UUID                             `json:"ebookId"`
				Id              openapi_types.UUID                             `json:"id"`
				LastReadAt      *time.Time                                     `json:"lastReadAt,omitempty"`
				Location        string                                         `json:"location"`
				ProgressPercent *float32                                       `json:"progressPercent,omitempty"`
				ReadingMode     ReaderReadingProgressGetById200DataReadingMode `json:"readingMode"`
				RowVersion      int                                            `json:"rowVersion"`
				UpdatedAt       time.Time                                      `json:"updatedAt"`
				UserId          openapi_types.UUID                             `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressGetById401Status  `json:"status"`
			Success ReaderReadingProgressGetById401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressGetById403Status  `json:"status"`
			Success ReaderReadingProgressGetById403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressGetById404Status  `json:"status"`
			Success ReaderReadingProgressGetById404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressGetById500Status  `json:"status"`
			Success ReaderReadingProgressGetById500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderReadingProgressUpdateResponse parses an HTTP response from a ReaderReadingProgressUpdateWithResponse call
func ParseReaderReadingProgressUpdateResponse(rsp *http.Response) (*ReaderReadingProgressUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderReadingProgressUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt       time.Time                                     `json:"createdAt"`
				DeletedAt       *time.Time                                    `json:"deletedAt,omitempty"`
				EbookId         openapi_types.UUID                            `json:"ebookId"`
				Id              openapi_types.UUID                            `json:"id"`
				LastReadAt      *time.Time                                    `json:"lastReadAt,omitempty"`
				Location        string                                        `json:"location"`
				ProgressPercent *float32                                      `json:"progressPercent,omitempty"`
				ReadingMode     ReaderReadingProgressUpdate200DataReadingMode `json:"readingMode"`
				RowVersion      int                                           `json:"rowVersion"`
				UpdatedAt       time.Time                                     `json:"updatedAt"`
				UserId          openapi_types.UUID                            `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                               `json:"message,omitempty"`
			Status  ReaderReadingProgressUpdate401Status  `json:"status"`
			Success ReaderReadingProgressUpdate401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                               `json:"message,omitempty"`
			Status  ReaderReadingProgressUpdate403Status  `json:"status"`
			Success ReaderReadingProgressUpdate403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                               `json:"message,omitempty"`
			Status  ReaderReadingProgressUpdate404Status  `json:"status"`
			Success ReaderReadingProgressUpdate404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                               `json:"message,omitempty"`
			Status  ReaderReadingProgressUpdate500Status  `json:"status"`
			Success ReaderReadingProgressUpdate500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderReadingProgressKillResponse parses an HTTP response from a ReaderReadingProgressKillWithResponse call
func ParseReaderReadingProgressKillResponse(rsp *http.Response) (*ReaderReadingProgressKillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderReadingProgressKillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                             `json:"message,omitempty"`
			Status  ReaderReadingProgressKill401Status  `json:"status"`
			Success ReaderReadingProgressKill401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                             `json:"message,omitempty"`
			Status  ReaderReadingProgressKill403Status  `json:"status"`
			Success ReaderReadingProgressKill403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                             `json:"message,omitempty"`
			Status  ReaderReadingProgressKill404Status  `json:"status"`
			Success ReaderReadingProgressKill404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                             `json:"message,omitempty"`
			Status  ReaderReadingProgressKill500Status  `json:"status"`
			Success ReaderReadingProgressKill500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderReadingProgressRestoreResponse parses an HTTP response from a ReaderReadingProgressRestoreWithResponse call
func ParseReaderReadingProgressRestoreResponse(rsp *http.Response) (*ReaderReadingProgressRestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderReadingProgressRestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt       time.Time                                      `json:"createdAt"`
				DeletedAt       *time.Time                                     `json:"deletedAt,omitempty"`
				EbookId         openapi_types.UUID                             `json:"ebookId"`
				Id              openapi_types.UUID                             `json:"id"`
				LastReadAt      *time.Time                                     `json:"lastReadAt,omitempty"`
				Location        string                                         `json:"location"`
				ProgressPercent *float32                                       `json:"progressPercent,omitempty"`
				ReadingMode     ReaderReadingProgressRestore200DataReadingMode `json:"readingMode"`
				RowVersion      int                                            `json:"rowVersion"`
				UpdatedAt       time.Time                                      `json:"updatedAt"`
				UserId          openapi_types.UUID                             `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressRestore401Status  `json:"status"`
			Success ReaderReadingProgressRestore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressRestore403Status  `json:"status"`
			Success ReaderReadingProgressRestore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressRestore404Status  `json:"status"`
			Success ReaderReadingProgressRestore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                                `json:"message,omitempty"`
			Status  ReaderReadingProgressRestore500Status  `json:"status"`
			Success ReaderReadingProgressRestore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareGetManyResponse parses an HTTP response from a ShareGetManyWithResponse call
func ParseShareGetManyResponse(rsp *http.Response) (*ShareGetManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareGetManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				BorrowDurationHours  int                           `json:"borrowDurationHours"`
				CreatedAt            time.Time                     `json:"createdAt"`
				DeletedAt            *time.Time                    `json:"deletedAt,omitempty"`
				Description          *string                       `json:"description,omitempty"`
				EbookId              openapi_types.UUID            `json:"ebookId"`
				Id                   openapi_types.UUID            `json:"id"`
				MaxConcurrentBorrows int                           `json:"maxConcurrentBorrows"`
				OwnerUserId          openapi_types.UUID            `json:"ownerUserId"`
				Status               ShareGetMany200DataStatus     `json:"status"`
				TitleOverride        *string                       `json:"titleOverride,omitempty"`
				UpdatedAt            time.Time                     `json:"updatedAt"`
				Visibility           ShareGetMany200DataVisibility `json:"visibility"`
			} `json:"data"`
			Limit      *float32              `json:"limit,omitempty"`
			Message    *string               `json:"message,omitempty"`
			Page       float32               `json:"page"`
			Status     ShareGetMany200Status `json:"status"`
			Success    *bool                 `json:"success,omitempty"`
			Total      *float32              `json:"total,omitempty"`
			TotalPages *float32              `json:"totalPages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareGetMany401Status  `json:"status"`
			Success ShareGetMany401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareGetMany403Status  `json:"status"`
			Success ShareGetMany403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareGetMany404Status  `json:"status"`
			Success ShareGetMany404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareGetMany500Status  `json:"status"`
			Success ShareGetMany500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareStoreResponse parses an HTTP response from a ShareStoreWithResponse call
func ParseShareStoreResponse(rsp *http.Response) (*ShareStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data struct {
				BorrowDurationHours  int                         `json:"borrowDurationHours"`
				CreatedAt            time.Time                   `json:"createdAt"`
				DeletedAt            *time.Time                  `json:"deletedAt,omitempty"`
				Description          *string                     `json:"description,omitempty"`
				EbookId              openapi_types.UUID          `json:"ebookId"`
				Id                   openapi_types.UUID          `json:"id"`
				MaxConcurrentBorrows int                         `json:"maxConcurrentBorrows"`
				OwnerUserId          openapi_types.UUID          `json:"ownerUserId"`
				Status               ShareStore201DataStatus     `json:"status"`
				TitleOverride        *string                     `json:"titleOverride,omitempty"`
				UpdatedAt            time.Time                   `json:"updatedAt"`
				Visibility           ShareStore201DataVisibility `json:"visibility"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  ShareStore401Status  `json:"status"`
			Success ShareStore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  ShareStore403Status  `json:"status"`
			Success ShareStore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  ShareStore404Status  `json:"status"`
			Success ShareStore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  ShareStore500Status  `json:"status"`
			Success ShareStore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareDestroyResponse parses an HTTP response from a ShareDestroyWithResponse call
func ParseShareDestroyResponse(rsp *http.Response) (*ShareDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareDestroy401Status  `json:"status"`
			Success ShareDestroy401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareDestroy403Status  `json:"status"`
			Success ShareDestroy403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareDestroy404Status  `json:"status"`
			Success ShareDestroy404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareDestroy500Status  `json:"status"`
			Success ShareDestroy500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareGetByIdResponse parses an HTTP response from a ShareGetByIdWithResponse call
func ParseShareGetByIdResponse(rsp *http.Response) (*ShareGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				BorrowDurationHours  int                           `json:"borrowDurationHours"`
				CreatedAt            time.Time                     `json:"createdAt"`
				DeletedAt            *time.Time                    `json:"deletedAt,omitempty"`
				Description          *string                       `json:"description,omitempty"`
				EbookId              openapi_types.UUID            `json:"ebookId"`
				Id                   openapi_types.UUID            `json:"id"`
				MaxConcurrentBorrows int                           `json:"maxConcurrentBorrows"`
				OwnerUserId          openapi_types.UUID            `json:"ownerUserId"`
				Status               ShareGetById200DataStatus     `json:"status"`
				TitleOverride        *string                       `json:"titleOverride,omitempty"`
				UpdatedAt            time.Time                     `json:"updatedAt"`
				Visibility           ShareGetById200DataVisibility `json:"visibility"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareGetById401Status  `json:"status"`
			Success ShareGetById401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareGetById403Status  `json:"status"`
			Success ShareGetById403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareGetById404Status  `json:"status"`
			Success ShareGetById404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareGetById500Status  `json:"status"`
			Success ShareGetById500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareUpdateResponse parses an HTTP response from a ShareUpdateWithResponse call
func ParseShareUpdateResponse(rsp *http.Response) (*ShareUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				BorrowDurationHours  int                          `json:"borrowDurationHours"`
				CreatedAt            time.Time                    `json:"createdAt"`
				DeletedAt            *time.Time                   `json:"deletedAt,omitempty"`
				Description          *string                      `json:"description,omitempty"`
				EbookId              openapi_types.UUID           `json:"ebookId"`
				Id                   openapi_types.UUID           `json:"id"`
				MaxConcurrentBorrows int                          `json:"maxConcurrentBorrows"`
				OwnerUserId          openapi_types.UUID           `json:"ownerUserId"`
				Status               ShareUpdate200DataStatus     `json:"status"`
				TitleOverride        *string                      `json:"titleOverride,omitempty"`
				UpdatedAt            time.Time                    `json:"updatedAt"`
				Visibility           ShareUpdate200DataVisibility `json:"visibility"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  ShareUpdate401Status  `json:"status"`
			Success ShareUpdate401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  ShareUpdate403Status  `json:"status"`
			Success ShareUpdate403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  ShareUpdate404Status  `json:"status"`
			Success ShareUpdate404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  ShareUpdate500Status  `json:"status"`
			Success ShareUpdate500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareBorrowResponse parses an HTTP response from a ShareBorrowWithResponse call
func ParseShareBorrowResponse(rsp *http.Response) (*ShareBorrowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareBorrowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data struct {
				BorrowerUserId      openapi_types.UUID       `json:"borrowerUserId"`
				CreatedAt           time.Time                `json:"createdAt"`
				DueAt               time.Time                `json:"dueAt"`
				ExpiredAt           *time.Time               `json:"expiredAt,omitempty"`
				Id                  openapi_types.UUID       `json:"id"`
				LegalAcknowledgedAt time.Time                `json:"legalAcknowledgedAt"`
				ReturnedAt          *time.Time               `json:"returnedAt,omitempty"`
				ShareId             openapi_types.UUID       `json:"shareId"`
				StartedAt           time.Time                `json:"startedAt"`
				Status              ShareBorrow201DataStatus `json:"status"`
				UpdatedAt           time.Time                `json:"updatedAt"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  ShareBorrow401Status  `json:"status"`
			Success ShareBorrow401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  ShareBorrow403Status  `json:"status"`
			Success ShareBorrow403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  ShareBorrow404Status  `json:"status"`
			Success ShareBorrow404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  ShareBorrow500Status  `json:"status"`
			Success ShareBorrow500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareKillResponse parses an HTTP response from a ShareKillWithResponse call
func ParseShareKillResponse(rsp *http.Response) (*ShareKillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareKillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  ShareKill401Status  `json:"status"`
			Success ShareKill401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  ShareKill403Status  `json:"status"`
			Success ShareKill403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  ShareKill404Status  `json:"status"`
			Success ShareKill404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  ShareKill500Status  `json:"status"`
			Success ShareKill500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareCreateReportResponse parses an HTTP response from a ShareCreateReportWithResponse call
func ParseShareCreateReportResponse(rsp *http.Response) (*ShareCreateReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareCreateReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data struct {
				CreatedAt        time.Time                      `json:"createdAt"`
				Details          *string                        `json:"details,omitempty"`
				Id               openapi_types.UUID             `json:"id"`
				Reason           ShareCreateReport201DataReason `json:"reason"`
				ReporterUserId   openapi_types.UUID             `json:"reporterUserId"`
				ResolutionNote   *string                        `json:"resolutionNote,omitempty"`
				ReviewedAt       *time.Time                     `json:"reviewedAt,omitempty"`
				ReviewedByUserId *openapi_types.UUID            `json:"reviewedByUserId,omitempty"`
				ShareId          openapi_types.UUID             `json:"shareId"`
				Status           ShareCreateReport201DataStatus `json:"status"`
				UpdatedAt        time.Time                      `json:"updatedAt"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareCreateReport401Status  `json:"status"`
			Success ShareCreateReport401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareCreateReport403Status  `json:"status"`
			Success ShareCreateReport403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareCreateReport404Status  `json:"status"`
			Success ShareCreateReport404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareCreateReport500Status  `json:"status"`
			Success ShareCreateReport500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareRestoreResponse parses an HTTP response from a ShareRestoreWithResponse call
func ParseShareRestoreResponse(rsp *http.Response) (*ShareRestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareRestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				BorrowDurationHours  int                           `json:"borrowDurationHours"`
				CreatedAt            time.Time                     `json:"createdAt"`
				DeletedAt            *time.Time                    `json:"deletedAt,omitempty"`
				Description          *string                       `json:"description,omitempty"`
				EbookId              openapi_types.UUID            `json:"ebookId"`
				Id                   openapi_types.UUID            `json:"id"`
				MaxConcurrentBorrows int                           `json:"maxConcurrentBorrows"`
				OwnerUserId          openapi_types.UUID            `json:"ownerUserId"`
				Status               ShareRestore200DataStatus     `json:"status"`
				TitleOverride        *string                       `json:"titleOverride,omitempty"`
				UpdatedAt            time.Time                     `json:"updatedAt"`
				Visibility           ShareRestore200DataVisibility `json:"visibility"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareRestore401Status  `json:"status"`
			Success ShareRestore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareRestore403Status  `json:"status"`
			Success ShareRestore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareRestore404Status  `json:"status"`
			Success ShareRestore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                `json:"message,omitempty"`
			Status  ShareRestore500Status  `json:"status"`
			Success ShareRestore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareUpsertReviewResponse parses an HTTP response from a ShareUpsertReviewWithResponse call
func ParseShareUpsertReviewResponse(rsp *http.Response) (*ShareUpsertReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareUpsertReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt  time.Time          `json:"createdAt"`
				DeletedAt  *time.Time         `json:"deletedAt,omitempty"`
				Id         openapi_types.UUID `json:"id"`
				Rating     int                `json:"rating"`
				ReviewText *string            `json:"reviewText,omitempty"`
				ShareId    openapi_types.UUID `json:"shareId"`
				UpdatedAt  time.Time          `json:"updatedAt"`
				UserId     openapi_types.UUID `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareUpsertReview401Status  `json:"status"`
			Success ShareUpsertReview401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareUpsertReview403Status  `json:"status"`
			Success ShareUpsertReview403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareUpsertReview404Status  `json:"status"`
			Success ShareUpsertReview404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                     `json:"message,omitempty"`
			Status  ShareUpsertReview500Status  `json:"status"`
			Success ShareUpsertReview500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSyncListEventsResponse parses an HTTP response from a SyncListEventsWithResponse call
func ParseSyncListEventsResponse(rsp *http.Response) (*SyncListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				BaseVersion     *int                            `json:"baseVersion,omitempty"`
				ClientTimestamp time.Time                       `json:"clientTimestamp"`
				CreatedAt       time.Time                       `json:"createdAt"`
				EntityId        openapi_types.UUID              `json:"entityId"`
				EntityType      SyncListEvents200DataEntityType `json:"entityType"`
				Id              openapi_types.UUID              `json:"id"`
				IdempotencyKey  string                          `json:"idempotencyKey"`
				Operation       SyncListEvents200DataOperation  `json:"operation"`
				Payload         *map[string]*interface{}        `json:"payload,omitempty"`
				ServerTimestamp time.Time                       `json:"serverTimestamp"`
				UserId          openapi_types.UUID              `json:"userId"`
			} `json:"data"`
			Limit      *float32                `json:"limit,omitempty"`
			Message    *string                 `json:"message,omitempty"`
			Page       float32                 `json:"page"`
			Status     SyncListEvents200Status `json:"status"`
			Success    *bool                   `json:"success,omitempty"`
			Total      *float32                `json:"total,omitempty"`
			TotalPages *float32                `json:"totalPages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                  `json:"message,omitempty"`
			Status  SyncListEvents401Status  `json:"status"`
			Success SyncListEvents401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                  `json:"message,omitempty"`
			Status  SyncListEvents403Status  `json:"status"`
			Success SyncListEvents403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                  `json:"message,omitempty"`
			Status  SyncListEvents404Status  `json:"status"`
			Success SyncListEvents404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                  `json:"message,omitempty"`
			Status  SyncListEvents500Status  `json:"status"`
			Success SyncListEvents500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSyncStoreEventResponse parses an HTTP response from a SyncStoreEventWithResponse call
func ParseSyncStoreEventResponse(rsp *http.Response) (*SyncStoreEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncStoreEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data struct {
				BaseVersion     *int                            `json:"baseVersion,omitempty"`
				ClientTimestamp time.Time                       `json:"clientTimestamp"`
				CreatedAt       time.Time                       `json:"createdAt"`
				EntityId        openapi_types.UUID              `json:"entityId"`
				EntityType      SyncStoreEvent201DataEntityType `json:"entityType"`
				Id              openapi_types.UUID              `json:"id"`
				IdempotencyKey  string                          `json:"idempotencyKey"`
				Operation       SyncStoreEvent201DataOperation  `json:"operation"`
				Payload         *map[string]*interface{}        `json:"payload,omitempty"`
				ServerTimestamp time.Time                       `json:"serverTimestamp"`
				UserId          openapi_types.UUID              `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                  `json:"message,omitempty"`
			Status  SyncStoreEvent401Status  `json:"status"`
			Success SyncStoreEvent401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                  `json:"message,omitempty"`
			Status  SyncStoreEvent403Status  `json:"status"`
			Success SyncStoreEvent403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                  `json:"message,omitempty"`
			Status  SyncStoreEvent404Status  `json:"status"`
			Success SyncStoreEvent404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                  `json:"message,omitempty"`
			Status  SyncStoreEvent500Status  `json:"status"`
			Success SyncStoreEvent500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserGetManyResponse parses an HTTP response from a UserGetManyWithResponse call
func ParseUserGetManyResponse(rsp *http.Response) (*UserGetManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserGetManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				CreatedAt       time.Time           `json:"createdAt"`
				DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
				Email           openapi_types.Email `json:"email"`
				EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
				GoogleId        *string             `json:"googleId,omitempty"`
				Id              openapi_types.UUID  `json:"id"`
				IsAdmin         *bool               `json:"isAdmin,omitempty"`
				LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
				UpdatedAt       time.Time           `json:"updatedAt"`
				Username        string              `json:"username"`
			} `json:"data"`
			Limit      *float32             `json:"limit,omitempty"`
			Message    *string              `json:"message,omitempty"`
			Page       float32              `json:"page"`
			Status     UserGetMany200Status `json:"status"`
			Success    *bool                `json:"success,omitempty"`
			Total      *float32             `json:"total,omitempty"`
			TotalPages *float32             `json:"totalPages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserGetMany401Status  `json:"status"`
			Success UserGetMany401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserGetMany403Status  `json:"status"`
			Success UserGetMany403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserGetMany404Status  `json:"status"`
			Success UserGetMany404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserGetMany500Status  `json:"status"`
			Success UserGetMany500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserStoreResponse parses an HTTP response from a UserStoreWithResponse call
func ParseUserStoreResponse(rsp *http.Response) (*UserStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data struct {
				CreatedAt       time.Time           `json:"createdAt"`
				DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
				Email           openapi_types.Email `json:"email"`
				EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
				GoogleId        *string             `json:"googleId,omitempty"`
				Id              openapi_types.UUID  `json:"id"`
				IsAdmin         *bool               `json:"isAdmin,omitempty"`
				LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
				UpdatedAt       time.Time           `json:"updatedAt"`
				Username        string              `json:"username"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  UserStore401Status  `json:"status"`
			Success UserStore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  UserStore403Status  `json:"status"`
			Success UserStore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  UserStore404Status  `json:"status"`
			Success UserStore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string             `json:"message,omitempty"`
			Status  UserStore500Status  `json:"status"`
			Success UserStore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderGetUserPreferencesResponse parses an HTTP response from a ReaderGetUserPreferencesWithResponse call
func ParseReaderGetUserPreferencesResponse(rsp *http.Response) (*ReaderGetUserPreferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderGetUserPreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt         time.Time                                        `json:"createdAt"`
				ReadingMode       ReaderGetUserPreferences200DataReadingMode       `json:"readingMode"`
				RowVersion        int                                              `json:"rowVersion"`
				ThemeMode         ReaderGetUserPreferences200DataThemeMode         `json:"themeMode"`
				ThemeOverrides    map[string]string                                `json:"themeOverrides"`
				TypographyProfile ReaderGetUserPreferences200DataTypographyProfile `json:"typographyProfile"`
				UpdatedAt         time.Time                                        `json:"updatedAt"`
				UserId            openapi_types.UUID                               `json:"userId"`
				ZenRestoreOnOpen  bool                                             `json:"zenRestoreOnOpen"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderGetUserPreferences401Status  `json:"status"`
			Success ReaderGetUserPreferences401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderGetUserPreferences403Status  `json:"status"`
			Success ReaderGetUserPreferences403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderGetUserPreferences404Status  `json:"status"`
			Success ReaderGetUserPreferences404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderGetUserPreferences500Status  `json:"status"`
			Success ReaderGetUserPreferences500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderPatchUserPreferencesResponse parses an HTTP response from a ReaderPatchUserPreferencesWithResponse call
func ParseReaderPatchUserPreferencesResponse(rsp *http.Response) (*ReaderPatchUserPreferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderPatchUserPreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt         time.Time                                          `json:"createdAt"`
				ReadingMode       ReaderPatchUserPreferences200DataReadingMode       `json:"readingMode"`
				RowVersion        int                                                `json:"rowVersion"`
				ThemeMode         ReaderPatchUserPreferences200DataThemeMode         `json:"themeMode"`
				ThemeOverrides    map[string]string                                  `json:"themeOverrides"`
				TypographyProfile ReaderPatchUserPreferences200DataTypographyProfile `json:"typographyProfile"`
				UpdatedAt         time.Time                                          `json:"updatedAt"`
				UserId            openapi_types.UUID                                 `json:"userId"`
				ZenRestoreOnOpen  bool                                               `json:"zenRestoreOnOpen"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderPatchUserPreferences401Status  `json:"status"`
			Success ReaderPatchUserPreferences401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderPatchUserPreferences403Status  `json:"status"`
			Success ReaderPatchUserPreferences403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderPatchUserPreferences404Status  `json:"status"`
			Success ReaderPatchUserPreferences404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderPatchUserPreferences500Status  `json:"status"`
			Success ReaderPatchUserPreferences500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderGetUserReaderStateResponse parses an HTTP response from a ReaderGetUserReaderStateWithResponse call
func ParseReaderGetUserReaderStateResponse(rsp *http.Response) (*ReaderGetUserReaderStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderGetUserReaderStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt       time.Time                                  `json:"createdAt"`
				CurrentEbookId  *openapi_types.UUID                        `json:"currentEbookId,omitempty"`
				CurrentLocation *string                                    `json:"currentLocation,omitempty"`
				LastOpenedAt    *time.Time                                 `json:"lastOpenedAt,omitempty"`
				ReadingMode     ReaderGetUserReaderState200DataReadingMode `json:"readingMode"`
				RowVersion      int                                        `json:"rowVersion"`
				UpdatedAt       time.Time                                  `json:"updatedAt"`
				UserId          openapi_types.UUID                         `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderGetUserReaderState401Status  `json:"status"`
			Success ReaderGetUserReaderState401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderGetUserReaderState403Status  `json:"status"`
			Success ReaderGetUserReaderState403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderGetUserReaderState404Status  `json:"status"`
			Success ReaderGetUserReaderState404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                            `json:"message,omitempty"`
			Status  ReaderGetUserReaderState500Status  `json:"status"`
			Success ReaderGetUserReaderState500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReaderPatchUserReaderStateResponse parses an HTTP response from a ReaderPatchUserReaderStateWithResponse call
func ParseReaderPatchUserReaderStateResponse(rsp *http.Response) (*ReaderPatchUserReaderStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReaderPatchUserReaderStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt       time.Time                                    `json:"createdAt"`
				CurrentEbookId  *openapi_types.UUID                          `json:"currentEbookId,omitempty"`
				CurrentLocation *string                                      `json:"currentLocation,omitempty"`
				LastOpenedAt    *time.Time                                   `json:"lastOpenedAt,omitempty"`
				ReadingMode     ReaderPatchUserReaderState200DataReadingMode `json:"readingMode"`
				RowVersion      int                                          `json:"rowVersion"`
				UpdatedAt       time.Time                                    `json:"updatedAt"`
				UserId          openapi_types.UUID                           `json:"userId"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderPatchUserReaderState401Status  `json:"status"`
			Success ReaderPatchUserReaderState401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderPatchUserReaderState403Status  `json:"status"`
			Success ReaderPatchUserReaderState403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderPatchUserReaderState404Status  `json:"status"`
			Success ReaderPatchUserReaderState404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                              `json:"message,omitempty"`
			Status  ReaderPatchUserReaderState500Status  `json:"status"`
			Success ReaderPatchUserReaderState500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserDestroyResponse parses an HTTP response from a UserDestroyWithResponse call
func ParseUserDestroyResponse(rsp *http.Response) (*UserDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserDestroy401Status  `json:"status"`
			Success UserDestroy401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserDestroy403Status  `json:"status"`
			Success UserDestroy403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserDestroy404Status  `json:"status"`
			Success UserDestroy404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserDestroy500Status  `json:"status"`
			Success UserDestroy500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserGetByIdResponse parses an HTTP response from a UserGetByIdWithResponse call
func ParseUserGetByIdResponse(rsp *http.Response) (*UserGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt       time.Time           `json:"createdAt"`
				DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
				Email           openapi_types.Email `json:"email"`
				EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
				GoogleId        *string             `json:"googleId,omitempty"`
				Id              openapi_types.UUID  `json:"id"`
				IsAdmin         *bool               `json:"isAdmin,omitempty"`
				LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
				UpdatedAt       time.Time           `json:"updatedAt"`
				Username        string              `json:"username"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserGetById401Status  `json:"status"`
			Success UserGetById401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserGetById403Status  `json:"status"`
			Success UserGetById403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserGetById404Status  `json:"status"`
			Success UserGetById404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserGetById500Status  `json:"status"`
			Success UserGetById500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserUpdateResponse parses an HTTP response from a UserUpdateWithResponse call
func ParseUserUpdateResponse(rsp *http.Response) (*UserUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt       time.Time           `json:"createdAt"`
				DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
				Email           openapi_types.Email `json:"email"`
				EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
				GoogleId        *string             `json:"googleId,omitempty"`
				Id              openapi_types.UUID  `json:"id"`
				IsAdmin         *bool               `json:"isAdmin,omitempty"`
				LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
				UpdatedAt       time.Time           `json:"updatedAt"`
				Username        string              `json:"username"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  UserUpdate401Status  `json:"status"`
			Success UserUpdate401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  UserUpdate403Status  `json:"status"`
			Success UserUpdate403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  UserUpdate404Status  `json:"status"`
			Success UserUpdate404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string              `json:"message,omitempty"`
			Status  UserUpdate500Status  `json:"status"`
			Success UserUpdate500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserKillResponse parses an HTTP response from a UserKillWithResponse call
func ParseUserKillResponse(rsp *http.Response) (*UserKillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserKillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string            `json:"message,omitempty"`
			Status  UserKill401Status  `json:"status"`
			Success UserKill401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string            `json:"message,omitempty"`
			Status  UserKill403Status  `json:"status"`
			Success UserKill403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string            `json:"message,omitempty"`
			Status  UserKill404Status  `json:"status"`
			Success UserKill404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string            `json:"message,omitempty"`
			Status  UserKill500Status  `json:"status"`
			Success UserKill500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserRestoreResponse parses an HTTP response from a UserRestoreWithResponse call
func ParseUserRestoreResponse(rsp *http.Response) (*UserRestoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserRestoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				CreatedAt       time.Time           `json:"createdAt"`
				DeletedAt       *time.Time          `json:"deletedAt,omitempty"`
				Email           openapi_types.Email `json:"email"`
				EmailVerifiedAt *time.Time          `json:"emailVerifiedAt,omitempty"`
				GoogleId        *string             `json:"googleId,omitempty"`
				Id              openapi_types.UUID  `json:"id"`
				IsAdmin         *bool               `json:"isAdmin,omitempty"`
				LastLoginAt     *time.Time          `json:"lastLoginAt,omitempty"`
				UpdatedAt       time.Time           `json:"updatedAt"`
				Username        string              `json:"username"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserRestore401Status  `json:"status"`
			Success UserRestore401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserRestore403Status  `json:"status"`
			Success UserRestore403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserRestore404Status  `json:"status"`
			Success UserRestore404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string               `json:"message,omitempty"`
			Status  UserRestore500Status  `json:"status"`
			Success UserRestore500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHealthGetHealthResponse parses an HTTP response from a HealthGetHealthWithResponse call
func ParseHealthGetHealthResponse(rsp *http.Response) (*HealthGetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthGetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Checks struct {
					Database struct {
						Error        *string                                    `json:"error,omitempty"`
						ResponseTime string                                     `json:"response_time"`
						Status       HealthGetHealth200DataChecksDatabaseStatus `json:"status"`
					} `json:"database"`
					Redis *struct {
						Error        *string                                 `json:"error,omitempty"`
						ResponseTime string                                  `json:"response_time"`
						Status       HealthGetHealth200DataChecksRedisStatus `json:"status"`
					} `json:"redis,omitempty"`
				} `json:"checks"`
				Environment string                       `json:"environment"`
				Status      HealthGetHealth200DataStatus `json:"status"`
				Timestamp   time.Time                    `json:"timestamp"`
			} `json:"data"`
			Message *string `json:"message,omitempty"`
			Status  *int    `json:"status,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Message *string                   `json:"message,omitempty"`
			Status  HealthGetHealth401Status  `json:"status"`
			Success HealthGetHealth401Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Message *string                   `json:"message,omitempty"`
			Status  HealthGetHealth403Status  `json:"status"`
			Success HealthGetHealth403Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string                   `json:"message,omitempty"`
			Status  HealthGetHealth404Status  `json:"status"`
			Success HealthGetHealth404Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Message *string                   `json:"message,omitempty"`
			Status  HealthGetHealth500Status  `json:"status"`
			Success HealthGetHealth500Success `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
