// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: core.sql

package sqlcdb

import (
	"context"
	"database/sql"
)

const clearSessionState = `-- name: ClearSessionState :exec
DELETE FROM session_state WHERE id = 1
`

func (q *Queries) ClearSessionState(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearSessionState)
	return err
}

const enqueueSyncOutboxEvent = `-- name: EnqueueSyncOutboxEvent :exec
INSERT INTO sync_events_outbox (
  id,
  entity_type,
  entity_id,
  operation,
  payload_json,
  base_version,
  idempotency_key,
  status,
  attempt_count,
  next_attempt_at,
  last_error,
  created_at,
  updated_at
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  'pending',
  0,
  ?8,
  NULL,
  ?9,
  ?10
)
ON CONFLICT(idempotency_key) DO NOTHING
`

type EnqueueSyncOutboxEventParams struct {
	ID             string         `json:"id"`
	EntityType     string         `json:"entity_type"`
	EntityID       string         `json:"entity_id"`
	Operation      string         `json:"operation"`
	PayloadJson    sql.NullString `json:"payload_json"`
	BaseVersion    sql.NullInt64  `json:"base_version"`
	IdempotencyKey string         `json:"idempotency_key"`
	NextAttemptAt  string         `json:"next_attempt_at"`
	CreatedAt      string         `json:"created_at"`
	UpdatedAt      string         `json:"updated_at"`
}

func (q *Queries) EnqueueSyncOutboxEvent(ctx context.Context, arg EnqueueSyncOutboxEventParams) error {
	_, err := q.db.ExecContext(ctx, enqueueSyncOutboxEvent,
		arg.ID,
		arg.EntityType,
		arg.EntityID,
		arg.Operation,
		arg.PayloadJson,
		arg.BaseVersion,
		arg.IdempotencyKey,
		arg.NextAttemptAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const getSessionState = `-- name: GetSessionState :one
SELECT access_token, refresh_token, user_id, updated_at
FROM session_state
WHERE id = 1
`

type GetSessionStateRow struct {
	AccessToken  string         `json:"access_token"`
	RefreshToken string         `json:"refresh_token"`
	UserID       sql.NullString `json:"user_id"`
	UpdatedAt    string         `json:"updated_at"`
}

func (q *Queries) GetSessionState(ctx context.Context) (*GetSessionStateRow, error) {
	row := q.db.QueryRowContext(ctx, getSessionState)
	var i GetSessionStateRow
	err := row.Scan(
		&i.AccessToken,
		&i.RefreshToken,
		&i.UserID,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSyncCheckpoint = `-- name: GetSyncCheckpoint :one
SELECT last_server_timestamp, last_event_id, updated_at
FROM sync_checkpoint
WHERE id = 1
`

type GetSyncCheckpointRow struct {
	LastServerTimestamp sql.NullString `json:"last_server_timestamp"`
	LastEventID         sql.NullString `json:"last_event_id"`
	UpdatedAt           string         `json:"updated_at"`
}

func (q *Queries) GetSyncCheckpoint(ctx context.Context) (*GetSyncCheckpointRow, error) {
	row := q.db.QueryRowContext(ctx, getSyncCheckpoint)
	var i GetSyncCheckpointRow
	err := row.Scan(&i.LastServerTimestamp, &i.LastEventID, &i.UpdatedAt)
	return &i, err
}

const getUserPreferencesCache = `-- name: GetUserPreferencesCache :one
SELECT user_id, reading_mode, zen_restore_on_open, theme_mode, theme_overrides_json, typography_profile, row_version, updated_at
FROM user_preferences_cache
WHERE user_id = ?1
LIMIT 1
`

func (q *Queries) GetUserPreferencesCache(ctx context.Context, userID string) (*UserPreferencesCache, error) {
	row := q.db.QueryRowContext(ctx, getUserPreferencesCache, userID)
	var i UserPreferencesCache
	err := row.Scan(
		&i.UserID,
		&i.ReadingMode,
		&i.ZenRestoreOnOpen,
		&i.ThemeMode,
		&i.ThemeOverridesJson,
		&i.TypographyProfile,
		&i.RowVersion,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUserReaderStateCache = `-- name: GetUserReaderStateCache :one
SELECT user_id, current_ebook_id, current_location, reading_mode, row_version, last_opened_at, updated_at
FROM user_reader_state_cache
WHERE user_id = ?1
LIMIT 1
`

func (q *Queries) GetUserReaderStateCache(ctx context.Context, userID string) (*UserReaderStateCache, error) {
	row := q.db.QueryRowContext(ctx, getUserReaderStateCache, userID)
	var i UserReaderStateCache
	err := row.Scan(
		&i.UserID,
		&i.CurrentEbookID,
		&i.CurrentLocation,
		&i.ReadingMode,
		&i.RowVersion,
		&i.LastOpenedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listActiveEbooksCache = `-- name: ListActiveEbooksCache :many
SELECT id, title, author, format, file_path, row_version, deleted_at, updated_at
FROM ebooks_cache
WHERE deleted_at IS NULL
ORDER BY updated_at DESC
`

func (q *Queries) ListActiveEbooksCache(ctx context.Context) ([]*EbooksCache, error) {
	rows, err := q.db.QueryContext(ctx, listActiveEbooksCache)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EbooksCache{}
	for rows.Next() {
		var i EbooksCache
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Format,
			&i.FilePath,
			&i.RowVersion,
			&i.DeletedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveSharesCache = `-- name: ListActiveSharesCache :many
SELECT id, ebook_id, owner_id, status, title, borrow_until, row_version, deleted_at, updated_at
FROM shares_cache
WHERE deleted_at IS NULL
ORDER BY updated_at DESC
`

func (q *Queries) ListActiveSharesCache(ctx context.Context) ([]*SharesCache, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSharesCache)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SharesCache{}
	for rows.Next() {
		var i SharesCache
		if err := rows.Scan(
			&i.ID,
			&i.EbookID,
			&i.OwnerID,
			&i.Status,
			&i.Title,
			&i.BorrowUntil,
			&i.RowVersion,
			&i.DeletedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingSyncOutboxEvents = `-- name: ListPendingSyncOutboxEvents :many
SELECT id,
  entity_type,
  entity_id,
  operation,
  payload_json,
  base_version,
  idempotency_key,
  status,
  attempt_count,
  next_attempt_at,
  last_error,
  created_at,
  updated_at
FROM sync_events_outbox
WHERE status = 'pending'
  AND next_attempt_at <= ?1
ORDER BY created_at ASC
LIMIT ?2
`

type ListPendingSyncOutboxEventsParams struct {
	Now       string `json:"now"`
	LimitRows int64  `json:"limit_rows"`
}

func (q *Queries) ListPendingSyncOutboxEvents(ctx context.Context, arg ListPendingSyncOutboxEventsParams) ([]*SyncEventsOutbox, error) {
	rows, err := q.db.QueryContext(ctx, listPendingSyncOutboxEvents, arg.Now, arg.LimitRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SyncEventsOutbox{}
	for rows.Next() {
		var i SyncEventsOutbox
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.Operation,
			&i.PayloadJson,
			&i.BaseVersion,
			&i.IdempotencyKey,
			&i.Status,
			&i.AttemptCount,
			&i.NextAttemptAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSyncOutboxEventRetry = `-- name: MarkSyncOutboxEventRetry :exec
UPDATE sync_events_outbox
SET attempt_count = attempt_count + 1,
  next_attempt_at = ?1,
  updated_at = ?2,
  last_error = ?3
WHERE id = ?4
`

type MarkSyncOutboxEventRetryParams struct {
	NextAttemptAt string         `json:"next_attempt_at"`
	UpdatedAt     string         `json:"updated_at"`
	LastError     sql.NullString `json:"last_error"`
	ID            string         `json:"id"`
}

func (q *Queries) MarkSyncOutboxEventRetry(ctx context.Context, arg MarkSyncOutboxEventRetryParams) error {
	_, err := q.db.ExecContext(ctx, markSyncOutboxEventRetry,
		arg.NextAttemptAt,
		arg.UpdatedAt,
		arg.LastError,
		arg.ID,
	)
	return err
}

const markSyncOutboxEventSucceeded = `-- name: MarkSyncOutboxEventSucceeded :exec
UPDATE sync_events_outbox
SET status = 'done',
  updated_at = ?1,
  last_error = NULL
WHERE id = ?2
`

type MarkSyncOutboxEventSucceededParams struct {
	UpdatedAt string `json:"updated_at"`
	ID        string `json:"id"`
}

func (q *Queries) MarkSyncOutboxEventSucceeded(ctx context.Context, arg MarkSyncOutboxEventSucceededParams) error {
	_, err := q.db.ExecContext(ctx, markSyncOutboxEventSucceeded, arg.UpdatedAt, arg.ID)
	return err
}

const searchActiveEbooksCache = `-- name: SearchActiveEbooksCache :many
SELECT id, title, author, format, file_path, row_version, deleted_at, updated_at
FROM ebooks_cache
WHERE deleted_at IS NULL
  AND (
    lower(title) LIKE '%' || lower(?1) || '%'
    OR lower(COALESCE(author, '')) LIKE '%' || lower(?1) || '%'
  )
ORDER BY updated_at DESC
`

func (q *Queries) SearchActiveEbooksCache(ctx context.Context, searchTerm string) ([]*EbooksCache, error) {
	rows, err := q.db.QueryContext(ctx, searchActiveEbooksCache, searchTerm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EbooksCache{}
	for rows.Next() {
		var i EbooksCache
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Format,
			&i.FilePath,
			&i.RowVersion,
			&i.DeletedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEbookCache = `-- name: UpsertEbookCache :exec
INSERT INTO ebooks_cache (
  id,
  title,
  author,
  format,
  file_path,
  row_version,
  deleted_at,
  updated_at
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8
)
ON CONFLICT(id) DO UPDATE SET
  title = excluded.title,
  author = excluded.author,
  format = excluded.format,
  file_path = excluded.file_path,
  row_version = excluded.row_version,
  deleted_at = excluded.deleted_at,
  updated_at = excluded.updated_at
`

type UpsertEbookCacheParams struct {
	ID         string         `json:"id"`
	Title      string         `json:"title"`
	Author     sql.NullString `json:"author"`
	Format     sql.NullString `json:"format"`
	FilePath   sql.NullString `json:"file_path"`
	RowVersion int64          `json:"row_version"`
	DeletedAt  sql.NullString `json:"deleted_at"`
	UpdatedAt  string         `json:"updated_at"`
}

func (q *Queries) UpsertEbookCache(ctx context.Context, arg UpsertEbookCacheParams) error {
	_, err := q.db.ExecContext(ctx, upsertEbookCache,
		arg.ID,
		arg.Title,
		arg.Author,
		arg.Format,
		arg.FilePath,
		arg.RowVersion,
		arg.DeletedAt,
		arg.UpdatedAt,
	)
	return err
}

const upsertSessionState = `-- name: UpsertSessionState :exec
INSERT INTO session_state (
  id,
  access_token,
  refresh_token,
  user_id,
  updated_at
) VALUES (
  1,
  ?1,
  ?2,
  ?3,
  ?4
)
ON CONFLICT(id) DO UPDATE SET
  access_token = excluded.access_token,
  refresh_token = excluded.refresh_token,
  user_id = excluded.user_id,
  updated_at = excluded.updated_at
`

type UpsertSessionStateParams struct {
	AccessToken  string         `json:"access_token"`
	RefreshToken string         `json:"refresh_token"`
	UserID       sql.NullString `json:"user_id"`
	UpdatedAt    string         `json:"updated_at"`
}

func (q *Queries) UpsertSessionState(ctx context.Context, arg UpsertSessionStateParams) error {
	_, err := q.db.ExecContext(ctx, upsertSessionState,
		arg.AccessToken,
		arg.RefreshToken,
		arg.UserID,
		arg.UpdatedAt,
	)
	return err
}

const upsertShareCache = `-- name: UpsertShareCache :exec
INSERT INTO shares_cache (
  id,
  ebook_id,
  owner_id,
  status,
  title,
  borrow_until,
  row_version,
  deleted_at,
  updated_at
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8,
  ?9
)
ON CONFLICT(id) DO UPDATE SET
  ebook_id = excluded.ebook_id,
  owner_id = excluded.owner_id,
  status = excluded.status,
  title = excluded.title,
  borrow_until = excluded.borrow_until,
  row_version = excluded.row_version,
  deleted_at = excluded.deleted_at,
  updated_at = excluded.updated_at
`

type UpsertShareCacheParams struct {
	ID          string         `json:"id"`
	EbookID     string         `json:"ebook_id"`
	OwnerID     string         `json:"owner_id"`
	Status      string         `json:"status"`
	Title       sql.NullString `json:"title"`
	BorrowUntil sql.NullString `json:"borrow_until"`
	RowVersion  int64          `json:"row_version"`
	DeletedAt   sql.NullString `json:"deleted_at"`
	UpdatedAt   string         `json:"updated_at"`
}

func (q *Queries) UpsertShareCache(ctx context.Context, arg UpsertShareCacheParams) error {
	_, err := q.db.ExecContext(ctx, upsertShareCache,
		arg.ID,
		arg.EbookID,
		arg.OwnerID,
		arg.Status,
		arg.Title,
		arg.BorrowUntil,
		arg.RowVersion,
		arg.DeletedAt,
		arg.UpdatedAt,
	)
	return err
}

const upsertSyncCheckpoint = `-- name: UpsertSyncCheckpoint :exec
INSERT INTO sync_checkpoint (
  id,
  last_server_timestamp,
  last_event_id,
  updated_at
) VALUES (
  1,
  ?1,
  ?2,
  ?3
)
ON CONFLICT(id) DO UPDATE SET
  last_server_timestamp = excluded.last_server_timestamp,
  last_event_id = excluded.last_event_id,
  updated_at = excluded.updated_at
`

type UpsertSyncCheckpointParams struct {
	LastServerTimestamp sql.NullString `json:"last_server_timestamp"`
	LastEventID         sql.NullString `json:"last_event_id"`
	UpdatedAt           string         `json:"updated_at"`
}

func (q *Queries) UpsertSyncCheckpoint(ctx context.Context, arg UpsertSyncCheckpointParams) error {
	_, err := q.db.ExecContext(ctx, upsertSyncCheckpoint, arg.LastServerTimestamp, arg.LastEventID, arg.UpdatedAt)
	return err
}

const upsertUserPreferencesCache = `-- name: UpsertUserPreferencesCache :exec
INSERT INTO user_preferences_cache (
  user_id,
  reading_mode,
  zen_restore_on_open,
  theme_mode,
  theme_overrides_json,
  typography_profile,
  row_version,
  updated_at
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8
)
ON CONFLICT(user_id) DO UPDATE SET
  reading_mode = excluded.reading_mode,
  zen_restore_on_open = excluded.zen_restore_on_open,
  theme_mode = excluded.theme_mode,
  theme_overrides_json = excluded.theme_overrides_json,
  typography_profile = excluded.typography_profile,
  row_version = excluded.row_version,
  updated_at = excluded.updated_at
`

type UpsertUserPreferencesCacheParams struct {
	UserID             string `json:"user_id"`
	ReadingMode        string `json:"reading_mode"`
	ZenRestoreOnOpen   int64  `json:"zen_restore_on_open"`
	ThemeMode          string `json:"theme_mode"`
	ThemeOverridesJson string `json:"theme_overrides_json"`
	TypographyProfile  string `json:"typography_profile"`
	RowVersion         int64  `json:"row_version"`
	UpdatedAt          string `json:"updated_at"`
}

func (q *Queries) UpsertUserPreferencesCache(ctx context.Context, arg UpsertUserPreferencesCacheParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserPreferencesCache,
		arg.UserID,
		arg.ReadingMode,
		arg.ZenRestoreOnOpen,
		arg.ThemeMode,
		arg.ThemeOverridesJson,
		arg.TypographyProfile,
		arg.RowVersion,
		arg.UpdatedAt,
	)
	return err
}

const upsertUserReaderStateCache = `-- name: UpsertUserReaderStateCache :exec
INSERT INTO user_reader_state_cache (
  user_id,
  current_ebook_id,
  current_location,
  reading_mode,
  row_version,
  last_opened_at,
  updated_at
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7
)
ON CONFLICT(user_id) DO UPDATE SET
  current_ebook_id = excluded.current_ebook_id,
  current_location = excluded.current_location,
  reading_mode = excluded.reading_mode,
  row_version = excluded.row_version,
  last_opened_at = excluded.last_opened_at,
  updated_at = excluded.updated_at
`

type UpsertUserReaderStateCacheParams struct {
	UserID          string         `json:"user_id"`
	CurrentEbookID  sql.NullString `json:"current_ebook_id"`
	CurrentLocation sql.NullString `json:"current_location"`
	ReadingMode     string         `json:"reading_mode"`
	RowVersion      int64          `json:"row_version"`
	LastOpenedAt    sql.NullString `json:"last_opened_at"`
	UpdatedAt       string         `json:"updated_at"`
}

func (q *Queries) UpsertUserReaderStateCache(ctx context.Context, arg UpsertUserReaderStateCacheParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserReaderStateCache,
		arg.UserID,
		arg.CurrentEbookID,
		arg.CurrentLocation,
		arg.ReadingMode,
		arg.RowVersion,
		arg.LastOpenedAt,
		arg.UpdatedAt,
	)
	return err
}
